<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>隻言片語</title>
    <link>https://stevearzh.github.io/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Mon, 19 Aug 2019 08:24:58 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>中序遍历的三种方法</title>
      <link>https://stevearzh.github.io/2019/08/19/three-inorder-traversal-ways/</link>
      <guid>https://stevearzh.github.io/2019/08/19/three-inorder-traversal-ways/</guid>
      <pubDate>Mon, 19 Aug 2019 06:19:39 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;不久前参加了字节跳动的面试，二面有一道算法题是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请使用非递归的方法中序遍历一颗二叉树&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿到题目的时候还是有点慌的，因为以前都是使用的递归的方法来中序遍历二叉树的。&lt;/p&gt;
&lt;h3 id=&quot;定
        
      
      </description>
      
      <content:encoded><![CDATA[<p>不久前参加了字节跳动的面试，二面有一道算法题是：</p><blockquote><p>请使用非递归的方法中序遍历一颗二叉树</p></blockquote><p>拿到题目的时候还是有点慌的，因为以前都是使用的递归的方法来中序遍历二叉树的。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>不管怎样，首先写出二叉树的节点结构：</p><pre><code class="cpp">struct TreeNode {  int val;  TreeNode *left;  TreeNode *right;  TreeNode(int x) : val(x), left(NULL), right(NULL) {}};</code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>首先，明确中序遍历是按照<strong>左 -&gt; 根 -&gt; 右</strong>的方式进行的，</p><p>然后观察递归的实现方式：</p><pre><code class="cpp">void recursiveInorder(TreeNode *root) {  if (root) {    recursiveInOrder(root -&gt; left);    cout &lt;&lt; root -&gt; val &lt;&lt; endl;    recursiveInOrder(root -&gt; right);  }}</code></pre><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>可以发现在通过递归实现的中序遍历里，有些遍历部分一开始是没有输出的，而是暂时通过递归的方式“缓存”了起来（比如一个节点的左子树同时有左子树和右子树的情况，那这个右子树就对应这种情况）。</p><p>接着我就思考这种“缓存”如果不是通过递归来实现的话，是不是可以通过栈来实现，把暂时不处理的节点存入栈里，一直到最左侧的没有左子树的节点为止。</p><p>但是没有想好怎么处理节点有右子树的情况，因为当时想的是栈只用来存左子树节点，然后左子树和右子树分为两种情况来处理，这样的话循环的终止条件是什么也就不确定了…卡了很久没想明白</p><p>感谢面试官抬了一手，在面试官的提示下修改算法为：</p><p>1.将 <code>root</code> 节点压入一个栈</p><p>2.开始循环，循环的终止条件是栈为空</p><p>3.取栈顶的元素（不弹出，也就是使用 <code>front</code> 而非 <code>pop</code>）为 <code>u</code></p><p>4.如果 <code>u</code> 有左子树，就把 <code>u</code> 的左子树压入栈中，然后跳转步骤 2</p><p>5.如果 <code>u</code> 没有左子树，那么就弹出（<code>pop</code>）并输出节点</p><p>6.如果弹出的节点 <code>u</code> 还有右子树，那么把右子树压入栈中，然后跳转步骤 2</p><p>最后根据算法写出代码：</p><pre><code class="cpp">void stackInorder(TreeNode *root) {  if (root) {    stack&lt;TreeNode&gt; s;    s.push(root);    while (!s.empty()) {      TreeNode *u = s.front();      if (u -&gt; left) {        s.push(u -&gt; left);      } else {        s.pop();        cout &lt;&lt; u -&gt; val &lt;&lt; endl;        if (u -&gt; right) {          s.push(u -&gt; right);        }      }    }  }}</code></pre><h3 id="Morris-Traversal"><a href="#Morris-Traversal" class="headerlink" title="Morris Traversal"></a>Morris Traversal</h3><p>面试完之后在 telegram 群里和大佬们说了这道面试题，大佬们说可以不用栈解决这个问题，只需要 O(n) 的时间复杂度和 O(1) 的空间复杂度。fc 教授说有个叫 <strong>Morris Traversal</strong> 的算法。</p><p>Google 一下找到了篇博客 —— <a href="https://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html" target="_blank" rel="noopener">Morris Traversal方法遍历二叉树（非递归，不用栈，O(1)空间）</a>。</p><p>引用一下算法的描述：</p><blockquote><p>1.如果当前节点的左孩子为空，则输出当前节点并将其右孩子作为当前节点。</p><p>2.如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点。</p><p> a) 如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。</p><p> b) 如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。</p><p>3.重复以上1、2直到当前节点为空。</p></blockquote><p>感觉精髓的地方是“<strong>如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点</strong>”。群里头大佬说的“穿线法”形容这个算法也特别形象。</p><p><img src="/img/three-inorder-traversal-ways/01.jpg" alt=""></p><p>双指针、穿线法。图片引自上面那篇博客。</p><p>代码如下：</p><pre><code class="cpp">void morrisInorder(TreeNode *root) {  TreeNode *cur = root, *prev = NULL;  while (cur) {    if (cur -&gt; left == NULL) {      cout &lt;&lt; cur -&gt; val &lt;&lt; endl;      cur = cur -&gt; right;    } else {              prev = cur -&gt; left;      while (prev -&gt; right &amp;&amp; prev -&gt; right != cur) {        prev = prev -&gt; right;      }      if (prev -&gt; right == NULL) {        prev -&gt; right = cur;        cur = cur -&gt; left;      } else {        prev -&gt; right = NULL;        cout &lt;&lt; cur -&gt; val &lt;&lt; endl;        cur = cur -&gt; right;      }    }  }}</code></pre>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/08/19/three-inorder-traversal-ways/#disqus_thread</comments>
    </item>
    
    <item>
      <title>为了忘却的记忆</title>
      <link>https://stevearzh.github.io/2019/06/26/the-forgotten-memory/</link>
      <guid>https://stevearzh.github.io/2019/06/26/the-forgotten-memory/</guid>
      <pubDate>Wed, 26 Jun 2019 06:04:38 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;前记：本来大抵是不想写这文章的，但上周一次不愉快的面试，最终面被 team leader 疯狂 diss，我觉得有必要把这些经历整理一下。不管怎样，那位负责人有句话说得还是很有道理的：“你应该从你的经历中总结出一些东西…”。有些事情如果不记下来，时
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>前记：本来大抵是不想写这文章的，但上周一次不愉快的面试，最终面被 team leader 疯狂 diss，我觉得有必要把这些经历整理一下。不管怎样，那位负责人有句话说得还是很有道理的：“你应该从你的经历中总结出一些东西…”。有些事情如果不记下来，时间长了我可能就真的忘了。</p></blockquote><h2 id="0"><a href="#0" class="headerlink" title="0"></a>0</h2><p>入职还要回到两年前的那个夏天。感谢 LA 师傅的推荐，我怀揣着惴惴不安的心情加入了这家黑客文化浓厚、创始人来自国内 top 3 高校的安全公司。</p><p>初来乍到一切都是那么新奇和美好。大概花费了一周左右的时间去装系统、学习 Vue、阅读项目源码…之后，我的座位被安排到了产品 monster 的旁边，加入了 WAF 组。</p><p>最开始分配给我的任务也就是调整 API，修理一些 UI 上的 bug 之类的小问题。然后就是接手需求，做一些新的组件、页面之类的。但是很多需求其实并不是很明确，也没有产品文档，甚至没有 UI 设计稿（当然有几次在我的强烈要求下还是会给出设计稿的），也没有明确的 deadline 告诉我哪一天要这个东西，只是说让我去做。</p><p>当时不太理解，或者说还没有适应这种工作模式，就浑浑噩噩的做这些东西，基本也都会在 monster 告诉什么时候要这个东西的时候把任务弄完。比较迷的原因还是在我自己，首先是头一次写 Vue，对各种 API 都不太熟（感觉没有 React 用的舒服）；其次业务我也不太熟悉，比如有哪些哪些模块，具体做了什么，我也都还在摸索，每次周会看到其他同事都能滔滔不绝的总结上周完成的事情，我都是三五句就说完了，也有种有力无处使的感觉，当时更多还是羡慕吧，觉得自己的技术还不到家；最后也就是我没有和产品 monster 很好的交流沟通了，但是接到任务之后我也会就需求，或者原型稿（如果有的话）提出一些我的问题和看法，但总感觉是没有得到正面回应或者说是被打太极一样推了回来。当然，主要问题还是在我。</p><p>产品 monster 以前其实是某安全实验室的黑客，后来加入现在这家公司后就转而做产品，因为初期公司缺人，好几个黑客师傅都转行去做其他业务了。monster 的技术很厉害，有几次下班之后学习 python、go、docker 之类的东西的时候还向他请教过问题，学到了不少东西。</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>然后就这样到了十月底，安服那边准备十一月中旬举办一场 CTF 比赛，但是那边没有前端开发了。很荣幸，我就被借调到了那个项目中去。和我对接的是运营 JiaJia 还有负责后端开发的 P 师傅，在我的强烈要求下才加入了设计师。</p><p>最开始啥都没有，只有一个写了些基本需求的 PPT，没有设计稿，甚至连产品原型都没画，告诉我可以自己技术选型，需要什么后端接口可以给 P 师傅说。我说这样不行，起码得有个设计稿我才能方便评估接下来的工作。</p><p>然后过了两三天的样子，设计稿出来的，但是看着特别糊，没有用心做。当时不太理解设计师为什么这么草率，但后来和其他同事聊天，才知道全公司就这么一个设计师，业务特别繁重，有点理解同情他了。</p><p>大概有五六个页面的样子，我就按照自己的评估写了个规划书，列举了每个页面大致会做多长时间，难点在哪里。最后总共的时间大概是在两周左右的样子。因为页面上很多东西其实都不确定，我留了一些时间。但是按照这个规划时间做完，可能只有两三天比赛就要开始了。</p><p>运营同学看了我的规划书就慌了，觉得自己处理不了，把安服的老大找了过了。安服老大问我为什么会花这么长时间，我就给他解释了一下，主要还是很多需求都是模糊不清的。安服老大表示不能接受，说最多只能给我一周的时间，因为活动需要提前宣传、选手注册之类的，不能太晚。这个时候我们研发这边的老板 Z 也过来了解情况。我说我不敢保证一周能弄完，只能说我尽量做，可以周末过来加班。Z 老板说行那你先这做着，每天和我同步一下进度。然后和安服老大商量了一下，大致就这么定了。</p><p>技术选型为了方便顺手当然是 React + Redux，为了挑战（尝鲜，稳定，… what ever）也开始使用了 TypeScript。感谢当时同在 WAF 组的 kingwl 师傅提供的帮助，虽然师傅之前也没有写过 TypeScript（师傅现在已经是 TypeScript 的前 50 的贡献者了），不过师傅一直在向我安利 elm。当时 Redux 配合 TypeScript 使用给我造成了不小的麻烦，在师傅的帮助下才算是折腾好。本来还纠结过要不要用 koa2 的，结果其他的师傅都劝我不要生产环境用 node…</p><p>最后周六加了天班，到第二周的周二下午差不多弄完了，花了七八个工作日的样子。很多东西开始做了也发现其实没有需求上那么高大上那么唬人，有些复杂的需求也是可以协商解决的（改成简单需求，或者直接砍掉）。</p><p>这任务大概就算圆满过去了。最后总结的时候每个人需要做个 PPT，然后交给 JiaJia 在总结会上做发言。我还找了周末下午去星巴克好好做了一份，然后发到只有 JiaJia、P 师傅、设计师还有我的微信群里。设计师还问我为啥要这么认真（why so serious），当时也不太理解设计师的心情，不过 JiaJia 和 P 师傅都说认真是对的，认真些好…</p><p>完事儿之后就又回到了 WAF 项目组。期间大概也还是按照之前的模式去工作。也做了一些类似拆分 2k 行 api 文件、重新组织 components 文件夹之类的小工作。然后就到春节了。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>大概就是绩效考核这么个东西。Z 老板把我叫去单聊，说我上一年的表现不太好，说我这个人有些懒惰。说实话当时有些懵逼，也不明白为啥会说我懒，内心充满了问号。就大概说了下可能是我不太能 get 到具体的需求是啥，然后想尽量把事情做完美之类的。然后表达了我还是想在技术上有所追求，想尝试接触一些后端业务的想法。老板表示明白了。说他要亲自带领一个项目（这项目存在也有一段时间了），准备把我调到他那个组去。我说行没问题。当时本来在尝试往 WAF 的前端项目里加入测试的，也就没继续研究了，大概和 kingwl 师傅交接了一下工作就去了新的项目组。</p><p>新的项目组是一个蜜罐系统。开发这边（前端+后端）总共就四个人（包括我）。有幸认识了 SZM 师傅和 ZWZ 师傅，还有和我一样不幸上一年绩效被打差评的 GXD 师傅。SZM 师傅是前端组长，带我搞前端这块儿东西；ZWZ 是后端组长，也是开发这边负责人，带 GXD 师傅搞后端那块儿。</p><p>SZM 师傅和 ZWZ 师傅都是硕士毕业，转行来的这个公司。说来惭愧，在互联网行业我混的比这两位师傅都要久，但是依然比两位师傅差了很远，无论是技术还是工作处世，也向他们学到了很多东西。包括 GXD 师傅在内，三位师傅的技术都特别强，在蜜罐组工作的这段时间是最有感觉的一段时间了。</p><p>再来介绍下蜜罐项目的相关情况。我来项目组之前，好像已经换过一两波人了。前端最开始是 Vue 写的，然后 SZM 大佬花了些时间迁移到了 React 上来，我来的时候这项工作已经接近尾声，我也负责了一小部分的迁移工作。然后就是引入了 TypeScript，处于和 JS 共存的局面。（过完年回来那阵）SZM 大佬特别强的在我还在调研的时候就搞出了方案来。后端那边听说以前负责后端的师傅不搞了，跑去当网管（运维）了，似乎是和产品闹得不快…然后产品也不在这个项目组了…所以才有了 Z 老板亲自当产品接手这个项目一说。（依旧没有 UI 设计师）</p><p>期间的经历只能用一言难尽这个词来形容。Z 老板在最开始的时候确实也是亲自参加周会，和我们分析需求、制定任务排期。但是到了后面，很多东西其实都推翻了最初的设定、超出预想，再加上 Z 老板也有其他业务要忙，就又招了两个产品助理，看上去也就是大学刚毕业的样子，老板就逐渐淡出了蜜罐这个项目。</p><p>虽说是产品助理，但感觉主要还是负责跑业务、拉客户，去客户那里部署项目之类的…产品上他们感觉也是揣测老板的意思，但老板本身想法其实也不确定，有时候他觉得应该是这么搞，但是来个人一说不该这么搞，要那么搞，老板也觉得有道理，不能坚持自己的观点。而且其中一个产品助理，还经常会和我们发表一些他对技术需求的看法：这个不难做吧，感觉一天就可以搞定了…之类的。</p><p>这就导致 ZWZ 师傅和 SZM 师傅特别苦逼，经常因为老板拍脑袋决定的原因，或者说下周要去客户那里演示之类的，加班到特别晚，甚至周末都要来加班。我和 GXD 师傅也会帮他们分担一些任务，但基本都是非临时性的（临时性的需求第一时间也不会通知到我们这边），我们基本也就是到点下班就走。期间我也如愿以偿的完了一些后端的业务，不过基本也就是参考师傅们之前的代码写的，了解了一点点的 Django 还有 DRF，接触了一些诸如序列化反序列化、原子性之类的概念。再往下到什么 PostgreSQL 还有 Redis 就不太懂了。</p><p>在后来一段任务需求不那么紧的时间里，我们也考虑了要不要和隔壁扫描器组一样尝试一下 GraphQL。当时 GXD 大佬大概调研两天之后就说不搞了，然后我有点不知天高地厚的说我来搞。</p><p>我和隔壁扫描器组一样选择了 Graphene 这个库，当时比较成熟的 GraphQL 的库也就这个了。难点不光在于要和 Django 以及 DRF 一起使用，隔壁组也是这样。我们这边实际上是 GraphQL 和 RESTFUL 两套协议并存的。为了配合 django 使用不得不引入 django-graphene 的库，然后当时我们这边有用到 django-filter 的库。本身用 graphene 写出来的接口是没有 limit, offset, total 这些分页参数的，为了配合之前的那些库又引入了叫 graphene-django-extras 的库，到了这里其实有些扭曲了…</p><p>当时遇到的一个难题是做模糊搜索，因为已经用了 django-filter 所以不能借用其他页面的实现方案，最后靠的是在 Github 下发 <a href="https://github.com/carltongibson/django-filter/issues/919" target="_blank" rel="noopener">issue</a> 提问才最终解决了问题。</p><p>做完这个东西之后感觉我还是欠缺很多后端的东西，可能确实不太适合做后端，也就没有再写其他的后端业务了。当时也因为过于低估任务难度，导致 deadline 快到的时候东西没做完，还和 SZM 大佬发生了一次争吵，很对不住他…</p><p>又过了一阵写组件写页面堆业务的时间之后，GXD 大佬就离职去了一家币圈公司。接着发生了一件我不知道怎么形容的事情。以前在极客邦的同事，去了掘金，突然发微信问我：“听说你们有个产品要开源了，是个蜜罐系统，叫MY。啥情况啊？”然后给我发了个文章链接。（忘了是掘金上的文章还是微信公众号的文章了）</p><p>我心里卧槽，这不是我现在做的项目吗，但是不叫这个名字啊？然后打开文章看了下，好像说的有模有样的。就把链接发到了工作群里，问 Z 老板啥情况，老板说不慌会上会解释。</p><p>之后的会上，老板说我们的目前的蜜罐会分为两个版本，原来的版本保持不变，对外销售；新的削减版会在 github 上开源，交给社区去发展。当时只觉得这事情有点魔幻。</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>又过了一个星期的样子 Z 老板又把我叫去聊天，不过这次倒不是绩效问题。老板表示想把我抽调到内部项目中去帮忙做 CRM 的前端重构。我问那现在蜜罐项目怎么办，老板说只留 SZM 大佬负责维护就可以。我说那行吧，就到了新的项目组。</p><p>当时大概是七月底还是八月初了，然后 CRM 项目开了个会。Z 老板表示现在的 CRM 虽然也勉强能用，但是操作特别繁琐，而且时常会有卡顿，希望我们重构一下，为将来考虑，支持最大 3000 并发。并且表示希望九月底可以上线重构版本替代现有版本。接着就是产品还是产品助理上来展示了一下半成品的产品原型稿，复杂的部分还没有做好。</p><p>开完会之后没几天，公司就搬家了，从园区最南头搬到了最北头。</p><p>先介绍下 CRM 这个项目的情况，最开始公司是没有这个项目的，用的外面买来的一套系统（不太清楚数据是放在自己这里还是别人那里）。后来老板们觉得用别人的东西非常不安全，毕竟自己也是做安全的，就决定从零开始自己开发一套 CRM 系统。</p><p>这个项目最开始应该是 pdd 师傅负责的，pdd 师傅技术也是特别强，是公司的初创员工之一，在大一还是大二就加入公司了。当时的技术选型是前端选择了 Vue + buefy + Nuxt.js，后端是 Nodejs + MongoDB。</p><p>但是选型定好之后没多久，pdd 师傅就因为有事回学校了，这个项目就交给了比我早入职一周的 frantic 师傅。师傅在当时那个时候也是相当的苦逼，全部项目组就只有他一个人，前端后端产品设计基本都是他一个人扛（升级上线之类的运维工作似乎主要是 pdd 师傅那边在维护），甚至还要经常参加销售的会议去了解定制需求（自己给自己提需求，自己开发）。也因此在来年年会上 Z 老板给了他“最了解销售的开发”大奖。直到后来扫描器项目开坑 frantic 师傅才得以跳出 CRM 项目去到扫描器那边，CRM 项目也因此停滞了将近半年时间。</p><p>本身刚到 CRM 这边我也以为我只是起到负责协助的作用的，需求也是特别模糊，只说要做优化，但是没说要做哪些优化。给我的感觉就是，老板说要把大象塞进冰箱，但是他只给我把冰箱门打开，要求我把大象放进去，再把门关上。具体怎么做看着办，但是东西希望能按时做出来。</p><p>后端那边 pdd 师傅已经从 nodejs 迁移到 golang 了，还是在用 mongodb，以及计划引入 graphql。</p><p>前端这边，说实话，看了产品给我的原型稿，我甚至觉得不如 frantic 师傅原来做的那个。而且本身给我的是原型稿不是设计稿，但是产品要求我像素级还原，当时做的是个日历，边框从方角改成了圆角，又从圆角改回了方角（就是 css 的 border-radius 属性），边框宽度也是改了很多次…</p><p>也尝试看了下以前的代码逻辑和实现，有很多扭曲的地方，比如权限系统的抽象，比如合同流程的签订之类的，也很难理解，甚至看到了销售那边的老板工号（不清楚是不是哈希过后的值）被硬编码到了代码里的操作…</p><p>一开始我其实是不想管这些东西的，只要把分配给我的任务弄完了就行。说我是前端负责人，其实前端这边其实也就我一个人…但是每次周会后 Z 老板都会找我单聊，关注项目前端的进度，表明他对这个项目的厚望。</p><p>大概两三次周会后吧，我觉得再这样下去不行，决定好好做一下这个事情（虽然我已开始就不太看好这个项目），也就是真正意义上的重构。首先我花费了一两天总结了一下项目中存在的问题，还有我不太好处理的地方。然后又找 frantic 师傅聊了一下，了解了一下他当时是怎么做这个项目的，当时他的一些设计和想法是什么样子的，具体这么处理好不好，是不是有更好的办法之类的。然后给 frantic 师傅说我准备把所有代码都重新写一下，师傅想了一下觉得没有问题。接着又去请教了一下 SZM 师傅，问他当时怎样说服老板把项目从 Vue 迁移到 React 的，也请教了一些其他的细节性的问题。</p><p>我整理了一下就写了个重构的提议书出来，大概讲了目前 CRM 的项目结构、重构愿景、有哪些不足、遇到了哪些问题等，最后给出了我的方案。因为当时只有我一个人在写前端，所以我的方案是基于 React 的。其实本身支持 3000 人并发这个和前端关系不大的，前端主要是优化操作流程，再就是工程上的规范代码保证稳定性方便以后多人协作之类的。</p><p>方案写完之后我先找到的 pdd 师傅聊，本来我以为 pdd 师傅也不负责前端这块，而且前端这里面 90% 的代码都不是他写的，大概就是他点个头然后我再去拿方案说服 Z 老板。</p><p>结果 pdd 师傅不同意重构，理由没有说，只是问我为啥不用 Vue 重构，我解释了目前只有我在写，当然是怎么快怎么来，但是如果非要用 Vue 重构我也不是不可以接受，只要重构就可以，理由方案书里已经写了。pdd 师傅又反问我为啥没有考虑 Angular？</p><p>于是我又回去，在方案书的最后加上了 Vue 和 Angular 两种方案的提议。改完之后我又去找 pdd 师傅聊，结果师傅还是不同意，但是理由没有。我说那不行就发到公司的技术群里吧，让大家给些意见。（因为一般来说如果大家遇到问题互相不能说服对方，就可以再找其他同事来评评理。）pdd 师傅一开始不同意，最后说那你要发就发吧。</p><p>发到技术群里之后，各位师傅也提出了一些自己的看法和建议。我修改了方案书之后再去找 pdd 师傅聊，师傅直接就告诉我：“你明天就不在这个项目组了。”</p><p>我当时满脸黑人问号，以为师傅说的是气话，也就不欢而散。结果快下班的时候 Z 老板又来找我谈话，说：“你和 pdd 师傅<strong>技术理念不合</strong>，我这边又准备搞个新的项目了，你来我这边吧，想用啥技术栈你自己随便选。”</p><p>说实话我当时有点生气了，我做调研查资料搞了那么久，合着你以为我是为了用新的框架和库才要重构的吗？我认真写了一份方案书，你一句技术理念不合就给我否定了？你以为我写代码是在这里过家家吗？pdd 师傅不懂事你老板也不懂事吗？你之前不是对这个项目期望挺大的吗？</p><p>因为去 CRM 项目组没几天的时候 Z 老板问过我春节之前会不会离职，我向老板保证过不会。当然新的项目组我肯定是不会去的，我怕还会发生同样的事情。所以，我想去相对成熟一些的项目组。当时还在蜜罐项目组的时候给扫描器帮过忙，写了一个星期的代码，感觉那边还算是相对比较完善的。就给 Z 老板说我想去扫描器项目组。Z 老板大概觉得有些头疼和无奈，还是说好。</p><p>现在再看大概老板还是想让我作为负责人带项目的吧，但是去了扫描器那边我就不是负责人了，因为 frantic 师傅已经在那边了。</p><p>在我去扫描器组的一周之后，ZWZ 师傅也从公司离职走了。</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>接着就要说到扫描器项目了。从定位上来看他是公司继 WAF、蜜罐之后的第三大产品。从工程化角度来看也是我呆过的项目中相对来说最规范的，起码是有测试、有 CI 的。不过同样的，没有设计师。</p><p>我到项目组差不多也是九月中旬了，也就是熟悉下环境阅读一下源码之类的。中秋十一之后工作继续。</p><p>可以看到这边其实隐约有了敏捷开发的雏形，或者说准备搞敏捷开发那一套东西。任务管理发布追踪都是在 jira 平台上进行，相应的工作记录、wiki 之类的则是在 confluence 上。</p><p>但是，又是这个但是，很多敏捷开发的核心要素这边还是没有掌握的。比如任务的粒度过大，经常出现史诗级任务，导致 deadline 经常是随意定的。换言之，经常会出现 jira 上分配的任务到期但是开发没有完成的情况。</p><p>刚开始的时候都没什么问题，即使是延期了但是任务也总归会完成，没有人来 blame 你是不是延期了或者催促要验收。似乎是开发和产品双方达成了一个默认协议，也就是说即使产品给布置了史诗级任务和一个大概的时间，开发这边也都会接受下来，延期之后只要是说一下就没啥问题，只要你还是在做尽心去这个东西。这个时期 jira 基本上算是一个摆设。</p><p>平衡被打破大致发生在十一月中旬的时候。也许是产品的管理层（上层）决定要彻底推行敏捷开发这一套东西，安排了一个产品助理来负责督促进度。当 jira 上的任务快到 deadline 的时候产品助理会去找相应的责任人催促。这就导致那段时间经常是处于一个手忙脚乱的状态，忙了这边忙那边。因为首先任务是直接塞给你的，没有评估一说，时间够不够你没法决定，而且会出现有的人突然在任务快到期的时候塞给你一个任务的情况出现。</p><p>而这位产品助理同学又特别的负责，这点必须要给与肯定，认真是好事情。但这也导致如果随便分配给你的任务你没注意 deadline（没仔细评估）导致没能按时完成的话，你会被两头 blame。</p><p>所以从那个时候开始，产品 JR 再给我分派新的需求的时候，我首先会单方面评估我能否在给定的期限内完成这个任务，如果不行的话我会去找产品进行协商，表明这个任务可能无法在指定期限内完成，并指出无法按时完成的客观原因，可以看看是不是需要把需求迭代到之后的排期内完成或者是削减需求以达到简单层面的实现。</p><p>但是，因为扫描器这个产品是还没有盈利（收入）的，导致会出现一些情况，销售那边在给客户演示产品的时候，客户会提到一些我们还没有的东西，销售会完全不考虑的给客户承诺说我们会做这个东西，回过头来产品就会要求我们把这些东西做出来（完全没有挡需求的人）。</p><p>而这种情况可能会出现在我在赶另外一个任务的 deadline 的时候，或者这个任务可能和我们项目初期的一些设定出现了不符、相矛盾、相冲突的东西。我会和 JR 说这个东西我这可能确实没法做，因为一些什么什么样的具体原因，如果要做是不是可以考虑推迟或者削减一下需求。但是 JR 强硬的说不行，必须要做。我就说那我确实做不了这个东西。开始的几次 JR 会说，那为什么 frantic 师傅和另外一个师傅就不会推这些东西。结果后来这两位师傅也会拒绝那些不合理的需求了。结果到某一次我又拒绝了 JR 之后，她发脾气说你要是不做我就去 LC（公司的技术负责人）那里告状了，我说你去告状我也还是这些理由，做不了。大概梁子就是这个时候结下了。</p><p>再后来项目又引入每周一早晨的周会制度，周会上会总结上周工作以及安排接下来一周要完成的哪些需求，相应的也会有需求的分解会，把具体的需求分配到个人。但是开发这边的感觉非但不是工作越来越顺利越来越有条理，而是越来越忙、越来越乱。上周的需求还没处理完的时候这周的需求又已经安排上了，形成了恶性循环。</p><p>终于，在十二月月底的某一天，被搞得疲惫不堪的我决定站出来说点东西。在一个夜不能寐的周日夜晚，我在床头举着手机总结了如下的一些点：</p><p><img src="/img/the-forgotten-memory/IMG_01.jpg" alt=""></p><p>并在第二天的周会上提出了这些问题。会后总结到了 confluence 上。并催生了《研发流程协议书》，由 Z 老板亲自撰写。</p><p>然后，时间推进到了一月，在我写出那份建议书之后，有些东西改了，比如 CI 时会加入测试分支，提交的代码不会直接合并到 master，jira 上的流程有了一些修改…但是大部分提议还是被忽视了。</p><p>时间再推进，到了春节之后，SZM 大佬也离职走了。</p><p>接着，出了件哭笑不得的事情。销售在某个周三卖出去了某个我们还没有做的产品。严格来说也并不能说没有做，举例来说我们原先的系统是 ABCDE 五个模块组成的，每个模块之间相互耦合，并非热插拔模式。但是销售给客户承诺我们可以单卖 ABC 模块，并表示我们下周就可以提供产品。这个消息周四快下班了才告诉我们。</p><p>周五的时候，后端 YY 师傅表示没问题，可以如期提交，并且提出了在原先代码的基础上进行删代码实现新产品的方案，并表示周末可以加班。我提出了反对意见，表示应该采用从零开始拷贝代码的方式去实现新产品，相应的也需要给出充足的开发时间。YY 师傅表示你怎么能确定你说的方案是对的，难道不应该是大家抱成一团往同一个方向使劲去做成一件事情吗？我说我没法保证我的提议一定是正确的，但是目前这个提议确实是存在不少的问题的，就算你赶工能完成这次任务但不能保证以后不会出现不可控的问题，对于抱团使劲这个我当时觉得有些上纲上线，没有评价。</p><p>接着，周五临近下班时通知开发，明天周六来加班。我又是表达了反对意见。本身这次需求就是临时塞进来的，没有在周一例会的规划中安排。如果是周一安排的需求，我没有完成，我可以接受加班，但是这次加班明显是因为不合理的项目需求规划导致的。结果反对无效，行吧，我周六还是过来了。</p><p>这个事情过去之后，我不再会去关注项目怎么搞了，只是尽力做好分配给我的工作。因为没办法，讲的道理提的意见全都没有用，还是该怎么搞怎么搞，该怎么玩儿怎么玩儿。随便打，各凭本事。</p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>再接着时间就到了清明节后。清明节前曾有过一次让我们自评的表格，为了绩效啥的。我想想去年做过的项目，大致写了写，给了自己一个中上的评价，感觉最终结果差不多应该也是这样吧。</p><p>结果年终奖拿到手，发现只拿到一个月，被扣了一个月，就感觉到已经被搞了。但也想着就这样吧，反正八月份合同到期我就走人了。</p><p>但是 4 月 10 号下午，HR 过来找我说要和我聊聊。当时第一反应是感觉不知道又要被踢到哪个项目组去了。结果 HR 开口跪：“你去年的绩效特别差，扫描器项目组这边决定不要你了。公司方面希望和你终止合同。按照 N + 1 走”。我愣了一下，说：“行吧，那我没问题”。大概 HR 以为我会有什么出格反应结果没有，也或许是为了缓和一下气氛，笑了下，说：“怎么，提前就猜到了吗？”“大概猜到了。”</p><p>我接着又问了：“能给我个理由吗？”“主管能动性不积极。”我有点不知道怎么评价…上一次看到这个词好像还是在考研政治里面。HR 接着又问了：“你觉得为什么会这样呢？”我有点无奈，甚至有点伤感，我尽力了，但是没想到背后会被捅了一刀：“大概是没有把这里当成家吧…”</p><p>HR 语塞了一下，又问我：“那你对你自己是怎么评价的呢？因为几乎所有人都给你打得差评。”这点我其实不太明白，因为当时绩效除了自我评价之外每个人还会随机分配到另外一个同事评价，比如我分配到的就是 YY 师傅的，因为我有过绩效被搞的经历，所以我给他的是全优评价。（不被别有用心的人拿来作为把柄）所以我不太明白“所有人给我差评”的所有人是指谁。当然我也没问，我明白这个潜意思就是有人搞我了。</p><p>“我觉得我做得没有什么问题，分配给我的工作，我认真、尽心尽力去完成。”我这么回复道。“那你为什么不主动推进以下项目呢？你的能力不止于此，为什么不主动包揽更多的工作去做，这样公司也好给你升职加薪呢？”HR 这么反问我。</p><p>当时的心里就是卧槽，我完成我分内的工作居然还不够，你还想让我做更多工作？但是我说道：“我怎么没有主动包揽推进拖项目？去年八月份的时候在 CRM 项目组那边我不是也尝试推进了吗？那最终结果是什么，我不是被  pdd 师傅踢出项目组才来到扫描器这边了吗？而且扫描器这边我的自评里也写了，我不是也针对项目的流程开发管理提出了我的建议和意见了吗？”</p><p>“那结果呢？” HR 问道。“结果就是，改了一部分，没有全改。我认为我还是对项目做出了一些贡献的。”</p><p>然后，就看 HR 像背书一样说道：“那这不符合常理呀。当员工通过帮助企业创造了价值的同时，会实现自我价值，产生很强烈的荣誉感和归属感。进而会在今后的工作生产中更加全身心得投入进去…那你为什么反而沦落到这个地步呢？”（原话记不清楚了，但是大致是这个意思）</p><p>我苦笑一下，问道：“这是你们人力资源管理里面的什么理论吧？” HR 点点头。“对我的这些负面评价应该也主要是在今年，或者说是春节之后吧？”“哦这点我不太清楚，因为我没详细问过他们这点。”</p><p>我又问：“那对我负面评价的点呢？”“比如你觉得你的代码质量怎么样？”“我认为我写的没有啥大问题，虽然我不能说优秀但我是尽心尽力去完成的。虽然有时候会就一些诸如写法风格之类的问题和 frantic 师傅发生一些争执，但最后也都是能合理解决的。”我倒是不担心，大不了找人来对峙，不过 HR 就没有就这个问题再接着说。</p><p>“是不是有一次加班，大家都来了，只有你没有来？”“那次加班本身就是不合理的，当时我也说了，不是因为预期的东西没有按时完成导致的加班，而是非预期不合理的安排导致的。而且那次加班我也来了。”“不是那次，之前还有一次。”我确实没印象了：“那我不记得了…”</p><p>“你也是从大厂里出来的人，应该是很厉害的…”“我认为评价一个人不应该从他是否去过大厂来评价，或者说不应该过于看他的以往经历”“那作为一个 HR 我们是没办法考察开发的技术水平的，当然也只能从他的过往经历来看”我想想也是，就点了点头。</p><p>“你当时为什么会选择我们这家公司呢？”“主要是比较好的技术氛围吧，大牛特别多，和他们一起工作能学到不少东西。但是从去年开始这些厉害的人相继离开，新招来的人说实话可能没有那么厉害。”</p><p>“那你觉得为什么会这样子呢，或者说他们的离职会对你造成影响吗？”“影响的话或多或少还是会有一些的吧。原因大概也就是随着公司的扩张，原有的人才会被稀释之类的。”“你看，你不是很明白吗。”我苦笑，摇了摇头。</p><p>“上面也对你感到非常惋惜，没想到你会走到这一步…”大概意思就是 Z 老板也知道我是被人搞了，而且默许了这次行动。HR 接着又说了：“上面对你的技术实力还是非常肯定的…”等一下，刚才还说了对我都是负面评价的，不过我没点破。我说：“我其实不是计算机专业出来的，我是转行过来的，我其实有很多知识上的欠缺，在我的自评里我也说了，我以后的目标其实是优先把这些欠缺的东西补上，比如算法、网络、操作系统…”</p><p>HR 又继续说道：“上面对你的技术是非常认可的，说很多人一辈子都无法达到你的高度，非常惋惜你为什么要这么浪费天赋…”我再次满脸黑人问号，我 TM 怎么就浪费天赋了？？？我说道：“没有，远的比和离职的哪些师傅，近的比如 kingwl 师傅，frantic 师傅，whtsky 师傅，我都是不如他们的。”</p><p>“那你对公司有什么疑问吗？”“我其实不太能接受春节之后搞的考勤制度，本来不是也提倡的自由办公，只要工作完成就可以的吗？”“那你觉得原因是什么呢？”“我明白，公司扩张之后人会变多，只要有一个人来得晚了那其他人就会觉得不公平，即使那个人走得晚甚至该干的工作也干了，但是你没法像所有人解释。而且大概也是为了统一管理，公司扩大的必经之路吧。”“你看，你又明白了，但是为什么你的所作所为没表现出来这点呢？”“虽然不满意但我也是按照考勤准时来到点走的吧…”而且理解不代表我认同这件事，当时没想到“认同”这个词，也就没这么说。</p><p>HR 又说道：“为什么你的想法很成熟，但是你的表现却不是这样呢？”我有些语塞，不知道怎么回。HR 继续说：“如果你表现的和你的想法一样成熟的话你大概也不会走到今天这一步了…” 我：“…” 说白了就是后悔要开了我了呗，但我也明白想让我离开不是 HR 的意思，她也只是替上面表态的。“你工作多久了？”“四年了。”“哦那你知道的挺多的，那些工作两三年的很多东西都不知道。”“四年和五年也差不了太多”“不一样，三到五年都是一样的”“…”行吧，估计又是什么人力资源管理理论了。</p><p>想着反正也要离职了，索性该问的都问了：“公司是不是快要没钱了？”“为什么这么问呢？”“去年还是前年那个时候融资了多少不是都告诉宣传了吗，然后从去年开始又是扩招又是换新办公室的，这些钱花不了太久的吧。而且产品在周会上还会告诉我们开发今年产品的目标销售额是多少多少钱，这不是急着变现吗？”“你们的工资不是还照常在发的吗？”“…”行吧，估计 HR 也不会很清楚这个东西。</p><p>HR 问了最后一个问题：“工作中最让你感到快乐的一件事是什么？”“就是工作（写代码）本身吧”，我答道。</p><p>然后就办理离职手续，走人。说实话我没想到 last day 会定在谈话当天。</p><p>本来以为我大概是公司有史以来第一个被开掉人，结果我被开的前一天已经有个师傅被开了，也是因为绩效给得很低，给他的理由是“缺乏职业素养”。</p><p>…大概是想搞什么末位淘汰制之类的，但是讲道理不是这么玩儿的啊。</p><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><p>最近找工作的时候，当问及离职原因，我为了简单起见，总结的直接原因：和产品有分析，产品给我的绩效（KPI）比较差，和公司协议离职。因为我不能像这篇文章一样说这么多对吧。</p><p>可能因为找的都是外企的缘故，他们估计也不太理解国内的 KPI。最开始我还会提到“主观能动性不积极”这个东西，我感觉这明显得就是扣帽子嘛，不过后面也不说了。反正面试到最后基本都不是因为技术不过关被挂掉，都是不明不白就没动静了。</p><p>上周面的那家面了四轮：第一轮是 HR 打电话过来背调，了解我的过往经历、离职原因之类的；第二轮在线做题；第三轮还是 HR，考察我的英语口语交流能力；第四轮（如果入职的话，未来的）直属上司，外国人，对我进行考察，包括聊我的过往经历、工作流程，还有上机（白板）写代码。大致都是很顺利的样子。我对他们的技术栈和技术架构也是比较感兴趣的。</p><p>结果到了第五轮，技术负责人一进门，我就感觉到了这个大叔的不友善。在简短的相互自我介绍之后，他先是问我为什么上家会离职，我说了原因。他接着问我分歧是什么，我说比如怎么去做好（打磨）一个产品，而不是只想着怎么赚钱？他问我什么叫打磨一个产品，有什么例子吗？我说比如你要做一个新功能，不是你确实做过调研分析了，应该做这个功能，而是我们的竞品有这个功能。</p><p>然后感觉他的语气有点不耐烦了：“你知道有进攻型产品和防御型产品一说吗？有的时候做一个产品仅仅只是为了防御的。”然后我和他说：“我认为进攻型产品和防御型产品应当仅仅是在公司已经在市场站稳了脚跟的情况下才会做的，比如你说 BAT 这种量级的公司，我是理解的。但是我之前所在的公司很明显还处在一种需要挤进市场，快速实现盈利这样一种状态。本身的融资经过这些年应该也是剩得不多了。”</p><p>然后技术负责人没有把这个话题继续下去，反问我：“你怎么会关注这些点。”“作为员工关注这些点没啥问题吧。”</p><p>“公司没想过培养你吗？”“大概还是有吧，之前有个 CRM 项目老板让我负责前端这块，说希望能支持最高 3000 人并发。我准备重构一下前端项目，调研了一周写了计划书，最后去找后端负责人商量的时候，他不同意，还把我从项目组踢了出来。”“他为什么不同意？”“我猜大概是因为这个项目最早是他发起的，尽管他没有写多少代码。”“那要是我我也不同意”“……”“你觉得你这件事有没有什么做得不对的地方？”我又想了想，说：“我觉得这件事我没有做得不对的地方。”</p><p>然后这位大叔就摆出了一付要教育我的样子来：“这件事应该算是对你职业生涯打击很大的一件事。很多时候，有些问题都不单单只是技术问题。你要和人多交流，保持你应有的尊重…”</p><p>其实抛开谈论的事情，他说得这话其实没有问题，但是他说这话很明显是在没有了解事情的全部的基础上发表的观点，当时给我的感觉就是为了怼我而怼我。但当时我没有怼回去，首先礼貌问题，其次毕竟万一入职了这可是大老板…</p><p>他又接着问我：“你没办法改变别人，你只能改变你自己。你再想想，如果再经历一次这种事你会怎么做？”…我只好想象了，说：“我大概会去先请他吃个饭，聊聊他对重构这件事的看法”“哎对了，交流是很关键的，要保持你的尊重”“……”</p><p>“你应该从你的经历中总结出一些东西…你工作多久了？”“四年了。”“不算太长，还年轻”“…”</p><p>最后聊完之后等了很久 HR 才过来，但是没有料到薪资问题，只是询问了一下我对面试的反馈。大概就猜到这次应该是又黄了。</p><p>于是，为了避免以后面试再经历同样的悲剧，写下了这篇文章…</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/06/26/the-forgotten-memory/#disqus_thread</comments>
    </item>
    
    <item>
      <title>说点什么</title>
      <link>https://stevearzh.github.io/2019/04/11/say-something/</link>
      <guid>https://stevearzh.github.io/2019/04/11/say-something/</guid>
      <pubDate>Thu, 11 Apr 2019 07:57:02 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;也许还会在某个午后&lt;/p&gt;
&lt;p&gt;来到学清路四爷牛拉&lt;/p&gt;
&lt;p&gt;从熙攘的顾客身旁挤过&lt;/p&gt;
&lt;p&gt;点一份尖椒肉丝盖饭&lt;/p&gt;
&lt;p&gt;还有椒麻鸡&lt;/p&gt;
&lt;p&gt;看着海贼漫画&lt;/p&gt;
&lt;p&gt;肆意地吞咽着美味&lt;/p&gt;
&lt;p&gt;在慵懒的阳光下穿过天桥&lt;/p&gt;
&lt;p&gt;走入对面便利
        
      
      </description>
      
      <content:encoded><![CDATA[<p>也许还会在某个午后</p><p>来到学清路四爷牛拉</p><p>从熙攘的顾客身旁挤过</p><p>点一份尖椒肉丝盖饭</p><p>还有椒麻鸡</p><p>看着海贼漫画</p><p>肆意地吞咽着美味</p><p>在慵懒的阳光下穿过天桥</p><p>走入对面便利店</p><p>从冰柜中取一瓶利趣拿铁</p><p>伴随着冲下喉头的凉爽</p><p>所有一切大致不过如此</p><p>那就这样吧</p><p><img src="/img/say-something/IMG_0123.jpeg" alt=""></p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/04/11/say-something/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Vodka Rickey</title>
      <link>https://stevearzh.github.io/2019/03/16/how-to-bartend-a-cup-of-vodka-rickey/</link>
      <guid>https://stevearzh.github.io/2019/03/16/how-to-bartend-a-cup-of-vodka-rickey/</guid>
      <pubDate>Sat, 16 Mar 2019 14:17:01 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;炎炎夏日，怎少得了爽口冷饮？下面来介绍如何调制一杯 Vodka Rickey。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;准备材料及器具：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;伏特加&lt;br&gt;&lt;img src=&quot;/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_
        
      
      </description>
      
      <content:encoded><![CDATA[<p>炎炎夏日，怎少得了爽口冷饮？下面来介绍如何调制一杯 Vodka Rickey。</p><hr><p>准备材料及器具：</p><ol><li>伏特加<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_1.jpg" alt=""></li><li>苏打水一瓶（330ml）<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_2.jpg" alt=""></li><li>青柠（小）若干<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_3.jpg" alt=""></li><li>冰块些许<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_4.jpg" alt=""></li><li>空玻璃杯一个<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_5.jpg" alt=""></li><li>调酒器<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_6.jpg" alt=""></li></ol><p>以上所有物品都可以在京东买到。青柠我没想到是这么小的，而且买的量有点多，一周的时间就坏了好多。</p><hr><p>制作步骤：</p><ol><li>把青柠切出一个小口，然后用手把柠檬汁挤入（会连籽一同挤入）调酒器中（如果是大青柠的话，就切片放入调酒器，然后利用擀面杖之类的工具捣出柠檬汁）：<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_7.jpg" alt=""></li><li>往调酒器中加入适量伏特加，连同上一步获得的柠檬汁一起，摇晃均匀后，倒入（注意不要倒入柠檬籽，如果是大青柠的话可以加入一两片青柠）到空玻璃杯：<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_8.jpg" alt=""><br>这个时候大概是发生了<a href="https://zh.wikipedia.org/wiki/%E9%85%AF%E5%8C%96%E5%8F%8D%E5%BA%94" target="_blank" rel="noopener">酯化反应</a>，可以闻一下：<strong>以柠檬汁的酸味和伏特加的酒精味相互抵消为宜</strong>。可酌情继续添加适量伏特加。</li><li>最后在玻璃杯中加入苏打水和冰块，vodka rickey 就制作完成了。<br><img src="/img/how-to-bartend-a-cup-of-vodka-rickey/IMG_9.jpg" alt=""></li></ol>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/03/16/how-to-bartend-a-cup-of-vodka-rickey/#disqus_thread</comments>
    </item>
    
    <item>
      <title>八皇后</title>
      <link>https://stevearzh.github.io/2019/03/06/eight-queens/</link>
      <guid>https://stevearzh.github.io/2019/03/06/eight-queens/</guid>
      <pubDate>Wed, 06 Mar 2019 12:38:28 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;国际象棋中皇后的攻击（移动）方式简单来说就是“米”字，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/eight-q
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>在8×8的国际象棋棋盘上放置八个皇后，使得任何一个皇后都无法直接吃掉其他的皇后</p></blockquote><p>国际象棋中皇后的攻击（移动）方式简单来说就是“米”字，如下图所示：</p><p><img src="/img/eight-queens/IMG_1.png" alt=""></p><p>八皇后问题乍看是从 8*8=64 个格子中选出一个子集，使得八个格子中的任意两个格子都不在同一行同一列同一对角线上。但这样的计算量是非常大的，总共有 8! 种可能性。这个思路行不通。</p><p>换个思路，从 64 个格子中选出 8 个格子（不分次序），则这个问题转换成了组合问题。但是计算量 64C8 也是非常巨大的，不能接受。</p><p>怎么办呢？再换一种思路。</p><p>首先我们知道国际象棋棋盘是8×8的，其次如果两个皇后相互无法攻击那这两个皇后一定<strong>不在同一行同一列同一对角线</strong>上。而问题刚好是放置 8 个皇后并使其相互之间无法攻击。也就是说，最终八个皇后一定是每行每列每条对角线上个一个。</p><p>如果写代码按照行号来进行循环的话，只要判断每列每条对角线上有没有其他皇后即可。</p><p>首先写出要用到的全局变量：</p><pre><code class="cpp">const int n = 8;int tot, C[n];</code></pre><p>这里 <code>n</code> 表示棋盘尺寸，<code>tot</code> 表示解的总数，<code>C[n]</code> 中存放了当前解的皇后摆法（第 i 个皇后的摆放位置是 (i, C[i])）。</p><p>怎么判断两个皇后是否在同一对角线上呢？</p><p>如果我们把国际象棋棋盘的行和列分别用 <code>y</code> 与 <code>x</code> 来表示，分别把行号列号相减、行号列号相加，可以发现如下图的规律：</p><p><img src="/img/eight-queens/IMG_2.png" alt=""></p><p>左上至右下的对角线（下文称主对角线）在行号 <code>y</code> 减列号 <code>x</code> 时，同一主对角线上的 <code>y - x</code> 的值相等；左下至右上的对角线（下文称副对角线）在行号 <code>y</code> 加列号 <code>x</code> 时，同一副对角线上的 <code>y + x</code> 的值相等。</p><p>由此可以得到解法：</p><pre><code class="cpp">void search(int cur) {  if (cur == n) {    tot++;    for (int i = 0; i &lt; n; i++) {      printf(&quot;%d &quot;, C[i]);    }    printf(&quot;\n&quot;);  } else {    for (int i = 0; i &lt; n; i++) {      int ok = 1;      C[cur] = i;      for (int j = 0; j &lt; cur; j++) {        if (C[cur] == C[j] || cur - C[cur] == j - C[j] || cur + C[cur] == j + C[j]) {          ok = 0;          break;        }      }      if (ok) {        search(cur + 1);      }    }  }}</code></pre><p>这个解法还可以继续优化，我们按照 <code>y - x</code> 和 <code>y + x</code> 的值的不同来区分不同的主副对角线，并将主副对角线分别设定为长度为 n*2 的数组，用来标记当前主副对角线上是否已放置皇后。再加上判断列号的长度为 n 的数组。（行号因为是循环标记变量，不用再行设置）添加如下全局变量：</p><pre><code class="cpp">int vis[3][n*2];</code></pre><p>解法代码也可相应修改为：</p><pre><code class="cpp">void search(int cur) {  if (cur == n) {    tot++;    for (int i = 0; i &lt; n; i++) {      printf(&quot;%d &quot;, C[i]);    }    printf(&quot;\n&quot;);  } else {    for (int i = 0; i &lt; n; i++) {      if (!vis[0][i] &amp;&amp; !vis[1][cur + i] &amp;&amp; !vis[2][cur - i + n]) {        C[cur] = i;        vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 1;        search(cur + 1);        vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 0;      }    }  }}</code></pre><p>最终完整代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;const int n = 8;int tot, C[n], vis[3][n*2];void search(int cur) {  if (cur == n) {    tot++;    for (int i = 0; i &lt; n; i++) {      printf(&quot;%d &quot;, C[i]);    }    printf(&quot;\n&quot;);  } else {    for (int i = 0; i &lt; n; i++) {      if (!vis[0][i] &amp;&amp; !vis[1][cur + i] &amp;&amp; !vis[2][cur - i + n]) {        C[cur] = i;        vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 1;        search(cur + 1);        vis[0][i] = vis[1][cur + i] = vis[2][cur - i + n] = 0;      }    }  }}int main(void) {  memset(vis, 0, sizeof(vis));  tot = 0;  search(0);  printf(&quot;total: %d\n&quot;, tot);  return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/03/06/eight-queens/#disqus_thread</comments>
    </item>
    
    <item>
      <title>骑士的移动</title>
      <link>https://stevearzh.github.io/2019/02/22/knight-moves/</link>
      <guid>https://stevearzh.github.io/2019/02/22/knight-moves/</guid>
      <pubDate>Fri, 22 Feb 2019 13:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;骑士的移动（&lt;a href=&quot;https://uva.onlinejudge.org/external/4/439.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Knight Moves, UVa 439&lt;/a&gt;）&lt;/p&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>骑士的移动（<a href="https://uva.onlinejudge.org/external/4/439.pdf" target="_blank" rel="noopener">Knight Moves, UVa 439</a>）</p><p>输入标准 8*8 国际象棋棋盘上的两个格子（列用 a~h 表示，行用 1~8 表示），求马最少需要多少步从起点跳到终点。例如从 a1 到 b2 需要四步。马的移动方式如下图所示。</p><p><img src="/img/knight-moves/IMG_1.png" alt=""></p><p>样例输入：</p><pre><code>e2 e4a1 b2b2 c3a1 h8a1 h7h8 a1b1 c3f6 f6</code></pre><p>样例输出：</p><pre><code>To get from e2 to e4 takes 2 knight moves.To get from a1 to b2 takes 4 knight moves.To get from b2 to c3 takes 2 knight moves.To get from a1 to h8 takes 6 knight moves.To get from a1 to h7 takes 5 knight moves.To get from h8 to a1 takes 6 knight moves.To get from b1 to c3 takes 1 knight moves.To get from f6 to f6 takes 0 knight moves.</code></pre></blockquote><hr><blockquote><p>题外话：还记得小时候老爹教我国际象棋的时候告诉我 —— 马是<strong>八面威风</strong>。</p></blockquote><p>这道题目说起来也是有意思。作为算法初心者，我拿到这道题目的时候第一感觉是：<em>这道题目要用 dfs 解决</em>。如果你知道答案，先别笑，听我慢慢分析。</p><p>首先设定棋盘大小：</p><pre><code class="cpp">const int maxn = 8;</code></pre><p>接着编写便于计算的结构体 <code>Node</code>，以及将输入的标识符转化为 <code>Node</code> 的方法 <code>id_to_node</code>：</p><pre><code class="cpp">struct Node {  int r, c;  Node(int r = 0, int c = 0): r(r), c(c) {}};Node id_to_node(const char* s) {  return Node(s[0] - &#39;a&#39;, s[1] - &#39;1&#39;);}</code></pre><p>添加判断边界条件的方法：</p><pre><code class="cpp">bool inside(Node u) {  return u.r &gt;= 0 &amp;&amp; u.r &lt; maxn &amp;&amp; u.c &gt;= 0 &amp;&amp; u.c &lt; maxn;}</code></pre><p>仔细观察上面图中马的移动方式，总结规律：</p><blockquote><p>如果马的初始坐标为 <code>(r, c)</code>，则马可以移动到的位置（不考虑边界条件）有：<code>(r+2, c-1)</code>, <code>(r+2, c+1)</code>, <code>(r+1, c+2)</code>, <code>(r-1, c+2)</code>, <code>(r-2, c+1)</code>, <code>(r-2, c-1)</code>, <code>(r-1, c-2)</code>, <code>(r+1, c-2)</code></p></blockquote><p>由此设定马下一步能移动的常量：</p><pre><code class="cpp">const int moves[8][2] = {{2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}};</code></pre><p>添加全局 <code>Node</code> 类型的变量 <code>u0</code> 和 <code>u1</code>，用于存储变换过后的初始状态和最终状态；以及全局二维整形数组变量 <code>m</code>，用于存储从初始状态至 <code>(r, c)</code> 的最小步数（<code>m</code> 中每个元素的初始值设为 <code>-1</code>，表示从初始状态起，还没有经过 <code>(r, c)</code> 这个点）：</p><pre><code class="cpp">Node u0, u1;int m[maxn][maxn];</code></pre><p>接着就要进入搜索的正题了，按照<em>先入为主的第一感觉</em>我采用了深度优先搜索：</p><pre><code class="cpp">void dfs(Node u, int last_move) {  if (!inside(u)) {    return; // out of bound  }  if (m[u.r][u.c] &gt; -1) {    return; // already visited, no need to continue  } else {    m[u.r][u.c] = last_move;  }  if (u.r == u1.r &amp;&amp; u.c == u1.c) {    return; // finished status  }  last_move += 1;  for (int i = 0; i &lt; 8; ++i) {    dfs(Node(u.r + moves[i][0], u.c + moves[i][1]), last_move);  }}</code></pre><p>其中参数 <code>u</code> 表示正在遍历的节点，<code>last_move</code> 表示遍历到当前节点已经花费的步数。</p><p>对 <code>dfs</code> 中三个不同的返回情况做下解释：第一种越界的情况是非法的，肯定不能继续运算了；最后一种找到最终结果之后，也不用继续计算了；第二种我当时的想法是，如果一个点已经被访问过了，那表示有其他搜索已经遍历过接下来的所有情况了，也就没有必要继续遍历了。</p><p>补全 <code>main</code> 函数：</p><pre><code class="cpp">int main(void) {  char s0[3], s1[3];  while (scanf(&quot;%s%s&quot;, s0, s1) == 2) {    u0 = id_to_node(s0);    u1 = id_to_node(s1);    memset(m, -1, sizeof(m));    dfs(u0, 0);    printf(&quot;To get from %s to %s takes %d knight moves.\n&quot;, s0, s1, m[u1.r][u1.c]);  }  return 0;}</code></pre><p>编译并输入测试数据运行：</p><p><img src="/img/knight-moves/IMG_2.png" alt=""></p><p>尼玛，哪里出问题了？！</p><p>检查并思考之后发现，发现上面的 <code>dfs</code> 中的第二种返回情况的依据：<em>“如果一个点已经被访问过了，那表示有其他搜索已经遍历过接下来的所有情况了，也就没有必要继续遍历了”</em>，是<strong>错误</strong>的。</p><p>原因是，当一个点被访问过的时候，已经访问的遍历方式并不一定是最优的解。</p><p>也就是说，在深度优先搜索的前提条件下，即使一个点已经被访问过了，那接下来还是要继续访问。</p><p>如果只是去掉第二个返回条件，再次编译运行后会出现 <strong><code>segmentation fault</code></strong>，没有终止条件是不行的。</p><p>在代码中限定最大搜索次数：</p><pre><code class="cpp">const int max_try = maxn;</code></pre><p>并修改第二个返回条件为：</p><pre><code class="cpp">if (last_move &gt; max_try) {  return; // exceed max try}if (m[u.r][u.c] &gt; -1) {  m[u.r][u.c] = std::min(m[u.r][u.c], last_move);} else {  m[u.r][u.c] = last_move;}</code></pre><p>编译运行测试数据，结果正确。</p><p>这就完了？并不是，尝试<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=submit_problem&amp;problemid=380&amp;category=" target="_blank" rel="noopener">提交答案</a>，结果打脸了：</p><p><img src="/img/knight-moves/IMG_3.png" alt=""></p><p>超时！</p><p>我横竖不甘心，上网尝试搜索答案，都不用仔细看，<em>所有的解法都写着 bfs</em>。看来<strong>先入为主的第一感觉不一定是正确的</strong>。QAQ</p><p>修改 <code>dfs</code> 为 <code>bfs</code> 结果如下：</p><pre><code class="cpp">void bfs(void) {  std::queue&lt;Node&gt; q;  q.push(u0);  m[u0.r][u0.c] = 0;  while (!q.empty() &amp;&amp; m[u1.r][u1.c] == -1) {    Node u = q.front();    q.pop();    for (int i = 0; i &lt; 8; ++i) {      Node next = Node(u.r + moves[i][0], u.c + moves[i][1]);      if (inside(next) &amp;&amp; m[next.r][next.c] == -1) {        q.push(next);        m[next.r][next.c] = m[u.r][u.c] + 1;      }    }  }}</code></pre><p>注意这里的往搜索队列 <code>q</code> 中 <code>push</code> 节点的判断条件：<code>inside(next) &amp;&amp; m[next.r][next.c] == -1</code> —— 没有越界并且没有被访问过。</p><p>为什么 <code>dfs</code> 中<em>节点没有被访问过</em>不能被当做边界条件，但是 <code>bfs</code> 可以呢？</p><p>因为广度优先搜索的顺序是按照<strong>距离根节点的顺序</strong>进行的，也就是说：<em>在广度优先搜索的前提下，如果一个节点已经被访问过了，那么之前访问这个节点的遍历方式<strong>一定优于</strong>这次访问这个节点的遍历方式</em>。</p><p>再次尝试提交代码：</p><p><img src="/img/knight-moves/IMG_4.png" alt=""></p><p>最终完整代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;const int maxn = 8;struct Node {  int r, c;  Node(int r = 0, int c = 0): r(r), c(c) {}};Node id_to_node(const char* s) {  return Node(s[0] - &#39;a&#39;, s[1] - &#39;1&#39;);}bool inside(Node u) {  return u.r &gt;= 0 &amp;&amp; u.r &lt; maxn &amp;&amp; u.c &gt;= 0 &amp;&amp; u.c &lt; maxn;}const int moves[8][2] = {{2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, {1, -2}};Node u0, u1;int m[maxn][maxn];void bfs(void) {  std::queue&lt;Node&gt; q;  q.push(u0);  m[u0.r][u0.c] = 0;  while (!q.empty() &amp;&amp; m[u1.r][u1.c] == -1) {    Node u = q.front();    q.pop();    for (int i = 0; i &lt; 8; ++i) {      Node next = Node(u.r + moves[i][0], u.c + moves[i][1]);      if (inside(next) &amp;&amp; m[next.r][next.c] == -1) {        q.push(next);        m[next.r][next.c] = m[u.r][u.c] + 1;      }    }  }}int main(void) {  char s0[3], s1[3];  while (scanf(&quot;%s%s&quot;, s0, s1) == 2) {    u0 = id_to_node(s0);    u1 = id_to_node(s1);    memset(m, -1, sizeof(m));    bfs();    printf(&quot;To get from %s to %s takes %d knight moves.\n&quot;, s0, s1, m[u1.r][u1.c]);  }  return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/02/22/knight-moves/#disqus_thread</comments>
    </item>
    
    <item>
      <title>树</title>
      <link>https://stevearzh.github.io/2019/02/17/tree/</link>
      <guid>https://stevearzh.github.io/2019/02/17/tree/</guid>
      <pubDate>Sun, 17 Feb 2019 06:25:29 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;树（&lt;a href=&quot;https://uva.onlinejudge.org/external/5/548.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tree, Uva 548&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;给一棵点带权（权
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>树（<a href="https://uva.onlinejudge.org/external/5/548.pdf" target="_blank" rel="noopener">Tree, Uva 548</a>）</p><p>给一棵点带权（权值各不相同，都是小于 10000 的正整数）的二叉树的中序和后序遍历，找到一个叶子使得它到根的路径上的权和最小。如果有多解，该叶子本身的权应尽量小。输入中每两行表示一棵树，其中第一行为中序遍历，第二行为后序遍历。</p><p>样例输入：</p><blockquote><p>3 2 1 4 5 7 6</p><p>3 1 2 5 6 7 4</p><p>7 8 11 3 5 16 12 18</p><p>8 3 11 7 16 18 12 5</p><p>255</p><p>255</p></blockquote><p>样例输出：</p><p>1</p><p>3</p><p>255</p><hr></blockquote><p>根据题目说明定义全局变量：</p><pre><code class="cpp">const int maxv = 10000 + 10;int in_order[maxv], post_order[maxv];</code></pre><p>以及使用数组 <code>lch</code> 与 <code>rch</code> 分别保存对应元素(1…10000)的左子树和右子树：</p><pre><code class="cpp">int lch[maxv], rch[maxv];</code></pre><p>因为<strong>中序遍历是按照“左 -&gt; 根 -&gt; 右”的顺序，后序遍历是按照“左 -&gt; 右 -&gt; 根”的顺序</strong>，也就是说：<em>后序遍历的最后一个字符就是根，只需要在中序遍历中找到它，就能知道左右子树的中序和后序遍历了</em>。这样就可以把二叉树构造出来（如下图所示），然后执行一次递归遍历，找到最优解。</p><p><img src="/img/tree/IMG_1.png" alt=""></p><p>写出根据中序遍历和后序遍历构造二叉树的方法：</p><pre><code class="cpp">// convert in_order[L1..R1] and post_order[L2..R2] to a binary-tree, then return rootint build(int L1, int R1, int L2, int R2) {  if (L1 &gt; R1) { // empty tree    return 0;  }  int root = post_order[R2];  int p = L1;  while (in_order[p] != root) {    p++;  }  int cnt = p - L1; // amount of the left child tree nodes  lch[root] = build(L1, p - 1, L2, L2 + cnt - 1);  rch[root] = build(p + 1, R1, L2 + cnt, R2 - 1);  return root;}</code></pre><p>以及<strong>深度遍历</strong>二叉树搜寻结果的方法：</p><pre><code class="cpp">int best, best_sum; // currently best solution and it&#39;s sumvoid dfs(int u, int sum) {  sum += u;  if (!lch[u] &amp;&amp; !rch[u]) { // leaf node    if (sum &lt; best_sum || (sum == best_sum &amp;&amp; u &lt; best)) {      best = u;      best_sum = sum;    }  }  if (lch[u]) {    dfs(lch[u], sum);  }  if (rch[u]) {    dfs(rch[u], sum);  }}</code></pre><p>最终代码如下：</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;const int maxv = 10000 + 10;int in_order[maxv], post_order[maxv], lch[maxv], rch[maxv];int n;bool read_list(int* a) {  string line;  if (!getline(cin, line)) {    return false;  }  stringstream ss(line);  n = 0;  int x;  while (ss &gt;&gt; x) {    a[n++] = x;  }  return n &gt; 0;}int build(int L1, int R1, int L2, int R2) {  if (L1 &gt; R1) {    return 0;  }  int root = post_order[R2];  int p = L1;  while (in_order[p] != root) {    p++;  }  int cnt = p - L1;  lch[root] = build(L1, p - 1, L2, L2 + cnt - 1);  rch[root] = build(p + 1, R1, L2 + cnt, R2 - 1);  return root;}int best, best_sum;void dfs(int u, int sum) {  sum += u;  if (!lch[u] &amp;&amp; !rch[u]) {    if (sum &lt; best_sum || (sum == best_sum &amp;&amp; u &lt; best)) {      best = u;      best_sum = sum;    }  }  if (lch[u]) {    dfs(lch[u], sum);  }  if (rch[u]) {    dfs(rch[u], sum);  }}int main(void) {  while (read_list(in_order)) {    read_list(post_order);    best_sum = 1000000000;    dfs(build(0, n - 1, 0, n - 1), 0);    cout &lt;&lt; best &lt;&lt; &quot;\n&quot;;  }  return 0;}</code></pre><p>针对第一组输入在找到最终答案后分别打印 <code>rch</code> 与 <code>lch</code> 如下图所示：</p><p><img src="/img/tree/IMG_2.png" alt=""></p><p>其中第一行是 1~7 的每个元素，第二行 <code>lch</code> 是每个元素的左子树指向的值，第三行 <code>rch</code> 是每个元素的右子树指向的值。参照前文分析相较验证。</p><hr><p>如果是基于指针的二叉树：</p><pre><code class="cpp">struct Node {  int value;  Node *left, *right;  Node(): left(NULL), right(NULL) {}};</code></pre><p>构建部分与搜索部分会有所变化：</p><pre><code class="cpp">void build(int L1, int R1, int L2, int R2, Node* root) {  root -&gt; value = post_order[R2];  int p = L1;  while (in_order[p] != root -&gt; value) {    p++;  }  int cnt = p - L1;  if (L1 &lt;= p - 1) {    root -&gt; left = newnode();    build(L1, p - 1, L2, L2 + cnt - 1, root -&gt; left);  }  if (p + 1 &lt;= R1) {    root -&gt; right = newnode();    build(p + 1, R1, L2 + cnt, R2 - 1, root -&gt; right);  }}void dfs(Node* u, int sum) {  sum += u -&gt; value;  if (!u -&gt; left &amp;&amp; !u -&gt; right) {    if (sum &lt; best_sum || (sum == best_sum &amp;&amp; u -&gt; value &lt; best)) {      best = u -&gt; value;      best_sum = sum;    }  }  if (u -&gt; left) {    dfs(u -&gt; left, sum);  }  if (u -&gt; right) {    dfs(u -&gt; right, sum);  }}</code></pre><p>完整代码：</p><pre><code class="cpp">#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;struct Node {  int value;  Node *left, *right;  Node(): left(NULL), right(NULL) {}};Node* newnode() {  return new Node();}void remove_tree(Node* u) {  if (u == NULL) {    return;  }  remove_tree(u -&gt; left);  remove_tree(u -&gt; right);  delete u;}const int maxv = 10000 + 10;int in_order[maxv], post_order[maxv];int n;bool read_list(int* a) {  string line;  if (!getline(cin, line)) {    return false;  }  stringstream ss(line);  n = 0;  int x;  while (ss &gt;&gt; x) {    a[n++] = x;  }  return n &gt; 0;}void build(int L1, int R1, int L2, int R2, Node* root) {  root -&gt; value = post_order[R2];  int p = L1;  while (in_order[p] != root -&gt; value) {    p++;  }  int cnt = p - L1;  if (L1 &lt;= p - 1) {    root -&gt; left = newnode();    build(L1, p - 1, L2, L2 + cnt - 1, root -&gt; left);  }  if (p + 1 &lt;= R1) {    root -&gt; right = newnode();    build(p + 1, R1, L2 + cnt, R2 - 1, root -&gt; right);  }}int best, best_sum;void dfs(Node* u, int sum) {  sum += u -&gt; value;  if (!u -&gt; left &amp;&amp; !u -&gt; right) {    if (sum &lt; best_sum || (sum == best_sum &amp;&amp; u -&gt; value &lt; best)) {      best = u -&gt; value;      best_sum = sum;    }  }  if (u -&gt; left) {    dfs(u -&gt; left, sum);  }  if (u -&gt; right) {    dfs(u -&gt; right, sum);  }}int main(void) {  while (read_list(in_order)) {    read_list(post_order);    best_sum = 1000000000;    Node *root = newnode();    build(0, n - 1, 0, n - 1, root);    dfs(root, 0);    cout &lt;&lt; best &lt;&lt; &quot;\n&quot;;    remove_tree(root);  }  return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/02/17/tree/#disqus_thread</comments>
    </item>
    
    <item>
      <title>也谈电影《流浪地球》</title>
      <link>https://stevearzh.github.io/2019/02/12/talk-about-movie-the-wandering-earth/</link>
      <guid>https://stevearzh.github.io/2019/02/12/talk-about-movie-the-wandering-earth/</guid>
      <pubDate>Tue, 12 Feb 2019 14:10:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;img src=&quot;/img/talk-about-movie-the-wandering-earth/IMG_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;有剧透。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在得知《流浪地球》电影要上映的时候，内心还是有些小激动的。作为一个曾经的科幻迷，初中
        
      
      </description>
      
      <content:encoded><![CDATA[<p><img src="/img/talk-about-movie-the-wandering-earth/IMG_1.jpg" alt=""></p><p>有剧透。</p><hr><p>在得知《流浪地球》电影要上映的时候，内心还是有些小激动的。作为一个曾经的科幻迷，初中高中时期大概连续购买了五六年的《科幻世界》杂志，一直到大学快毕业（也不知道为啥）才渐渐不看了。还记得 10 年高考完那阵，为了加入刘慈欣 QQ 群（当然是粉丝建的），疯狂研读他的每部小说（进群是有考试的，而且挺难，很多问题搜索不到，比如大刘三部曲是哪三部），进群之后甚至和群友学会了三国杀… 那个时候科幻挺小众的，尤其是中国科幻。</p><p>两年前《三体》火的的时候就有点不明白：最早看这书还是高二的时候，借着下载资料的契机，用我妈单位电脑上网，下载到文曲星里，用各种时间偷摸看完。也曾试着给别人安利这书，基本都是一笑而过、不了了之。结果工作之后，这书火了（感谢雨果奖），身边的朋友、同事还有网上，到处都在讨论这本书。而且也只有《三体》火了，大刘的其他小说、国内其他科幻作家，依旧无人知晓。</p><p>提前购买了 2 月 10 号晚上九点家附近电影院的票。春节放假结束下午回到北京，洗漱收拾完毕后，剩余的时间只够去电影院楼下吃顿麦当劳。说实话最开始对这电影期望不大，首先国内没拍过啥大片，近年来又是各种流量电影，我在电影院里看过的国产片屈指可数，也很反感贩卖情怀（战狼2至今未从任何渠道观看，没有黑的意思），再加上早几年夭折的《三体》电影… 结果《流浪地球》电影上映之后风评居然还不错？这也进一步提起了我的兴趣。</p><hr><p>大学毕业之后就没读过科幻小说了，《流浪地球》的具体故事情节也忘记的差不多了（看完电影回家复习了一下）。但是看电影时我最大的感受就是：这电影很不大刘。大刘写的小说设定严谨（中国硬科幻代表作家），场景宏大辽阔，能给人以很强烈的震撼，以及不得不提的政治描写。相对的，大刘的文字中感情述说则有些薄弱，单从《三体》系列里的罗辑和庄严、云天明和程心就能看出。但这一点可以藉由大刘小说带给人的震撼来弥补：无论是《朝闻道》中的“朝闻道，夕死可矣”，还是《诗云》中的“诗云”，大刘总能用他文字颠覆你的想象，让你思索人生、未来，还有宇宙。</p><p>可在电影中，无论是广袤无垠的寒冷冰原，还是最后决定地球存亡的危急关头，人物的对话行为都只是很中国风的煽情（不是说演得不好，演得很好，我也很感动）。还有知乎里提到的反好莱坞大片的套路（刘户口姥爷牺牲、杭州地下城失陷、饱和式救援等），这些“细节”都不是大刘会写的东西，即使会写也是一笔带过。</p><p>电影中抛开“流浪地球”计划本身，包括整个电影讲述的让地球免于撞毁在木星上这件事，都不是原著小说中讲的，电影只是借用了“流浪地球”这个概念。小说里地球是依靠太阳和木星的引力实现椭圆轨道加速逃逸太阳系。流浪地球的五个阶段：刹车时代、逃逸时代、流浪时代Ⅰ(加速)、流浪时代Ⅱ(减速)、新太阳时代，电影里基本只有逃逸时代，只在最后的新闻（还是谈话）里提到了其他阶段。还有无论是小说一开始的“地球派”与“飞船派”之争，还是最后决定小说基调的“太阳派”处决“地球派”的场景，电影里全都没有。（按照朋友的说法，最后处决场景要是演了可能无法过审）</p><p>抛开小说，仅从电影角度讨论，很多（煽情的）场景都给我一种用力过猛的感觉。代表就是最后韩朵朵发表动员演讲的时候 —— 按照当时的情景，地球马上就要撞上木星了，你要做的就是用尽量简短精准的话语，向正在收听广播的救援队群众，描述你们的点燃木星的计划；而不是浪费时间从感情上去打动他们，每个人的经历都不尽相同，这么做不一定有用而且没必要。</p><p>剧情方面我只能给出 6/10 分。</p><hr><p>接着说一下电影的画面（氛围）。一开始地下城市里的春节情景，不像是末世高科技地下城，而像是民国时期的旧上海滩；尤其是刘户口带着妹妹朵朵去骗取外出的宇航服头盔身份牌的时候，给我的感觉是《追龙》里甄子丹独闯黑帮的场面。人物的言行举止也都感觉不属于那个时代（没有科幻片的即视感）。</p><p>紧接着升到地面上，寒冷荒芜的旧城废墟，让我这个辐射粉眼前一亮。这种核战后的废土风很有感觉，再加上蒸汽/机械朋克风格的重型卡车，简直完美。北京市第三交通委提醒您：道路千万条，安全第一条，行车不规范，亲人两行泪。也是槽点满满。</p><p>太空站的建模很有未来的科技感；每个人说各自的语言靠同声传译是一大亮点；前往总控室的一系列行动有好莱坞大片的感觉了；不过 MOSS 的设定还是有点尬，居然被一瓶 Vodka 给解决了，没有分布式什么的吗。</p><p>地球撞击木星的建模，没想到就是个贴图，电影里的感觉甚至还不如之前的宣传片震撼，是不是资金不够导致的…最后刘培强驾驶总控舱撞击木星的场景，感觉是在致敬某部大片，很震撼。</p><p>画面方面我给 8/10 分。</p><hr><p>特效、音效中规中矩吧，没有太多的感觉。有一线大片的水准了，但距离顶级大片还差一些。评分 7/10。</p><p>除去原著还原度不高的缺点，这是一部好的科幻大片，非常值得一看。毕竟这是中国第一部真正的科幻电影，同时继《三体》之后再一次把中国科幻推向公众的视野，让更多的人能接触、了解到原本非常小众的中国科幻。看完电影刚出电影院的时候，我在微信群里和朋友说，我给这电影打 9/10 分。就当做情怀分吧。</p><p>最终评分：(6/10 + 8/10 + 7/10 + 7/10 + 9/10) ÷ 5 = 7.4/10</p><hr><p>PS.国内其他优秀科幻作家推荐：王晋康（老王）、何夕、柳文扬、韩松等。主要是我高中到大学时期的，新的科幻作家（如郝景芳等）了解不多，因为科幻看得少了。</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/02/12/talk-about-movie-the-wandering-earth/#disqus_thread</comments>
    </item>
    
    <item>
      <title>树的层次遍历</title>
      <link>https://stevearzh.github.io/2019/01/30/trees-on-the-level/</link>
      <guid>https://stevearzh.github.io/2019/01/30/trees-on-the-level/</guid>
      <pubDate>Wed, 30 Jan 2019 12:33:04 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;树的层次遍历（&lt;a href=&quot;https://uva.onlinejudge.org/external/1/122.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Trees on the level, Duke 1993
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>树的层次遍历（<a href="https://uva.onlinejudge.org/external/1/122.pdf" target="_blank" rel="noopener">Trees on the level, Duke 1993, UVa 122</a>）</p><p>输入一颗二叉树，你的任务是从上到下、从左到右的顺序输出各个节点的值。每个节点都按照从根节点到它的移动序列给出（L 表示左，R 表示右）。在输入中，每个节点的左括号和右括号之间没有空格，相邻节点之间用一个空格隔开。每棵树的输入用一对空括号“()”结束（这对括号本身不代表一个节点），如下图所示：</p><p><img src="/img/trees-on-the-level/IMG_1.png" alt=""></p><p>注意，如果从根到某个叶节点的路径上有的节点没有在输入中给出，或者给出超过一次，应当输入-1。节点个数不超过 256 个。</p><p>样例输入：</p><blockquote><p>(11,LL) (7,LLL) (8,R) (5,) (4,L) (13,RL) (2,LLR) (1,RRR) (4,RR) ()</p><p>(3,L) (4,R) ()</p></blockquote><p>样例输出：</p><blockquote><p>5 4 8 11 13 4 7 2 1</p><p>-1</p></blockquote></blockquote><hr><p>首先定义全局变量：</p><pre><code class="cpp">#define maxn 256 + 10 // 节点的最大个数char s[maxn]; // 保存读入的节点字符串bool failed;  // 是否有从根到某个叶节点的路径上有的节点没有在输入中给出，或者给出超过一次Node *root; // 二叉树的根节点</code></pre><p>接着分析输入：</p><ul><li>每行输入均由若干个形如 “(<value>,[position])” 的字符串组成</value></li><li>每行输入的末尾都是 “()”</li></ul><p>由此可以得到读取输入的函数 <code>read_input</code>：</p><pre><code class="cpp">bool read_input() {  failed = false;  root = newnode();  for (;;) {    if (scanf(&quot;%s&quot;, s) != 1) {      return false;    }    if(!strcmp(s, &quot;()&quot;)) {      break;    }    int v;    sscanf(&amp;s[1], &quot;%d&quot;, &amp;v);    addnode(v, strchr(s, &#39;,&#39;) + 1);  }  return true;}</code></pre><blockquote><p>程序不难理解：不停读入节点，如果在读到空括号之前文件结束，则返回 0（这样，在 main 函数里就能得知输入结束）。注意，这里两次用到了 C 语言中字符串的灵活性 —— <strong>可以把任意“指向字符的指针”看成是字符串，从该位置开始，直到字符“\0”</strong>。例如，若读到的节点是 <code>(11,LL)</code>，则 <code>&amp;s[1]</code> 所对应的字符串是 <code>&quot;11,LL&quot;</code>。函数 <code>strchr(s, &#39;,&#39;)</code> 返回字符串 <code>s</code> 中从左往右第一个字符 <code>&quot;,&quot;</code> 的指针，因此 <code>strchr(s, &#39;,&#39;) + 1</code> 所对应的字符串是 <code>&quot;LL)&quot;</code>。这样，实际调用的是 <code>addnode(11, &quot;11)&quot;)</code>。</p></blockquote><hr><p>接着编写二叉树的节点 <code>Node</code>。根据题目里的说明，可以分析出二叉树的节点拥有以下的几个属性：</p><ul><li>节点上的值 value</li><li>左子树的节点 left</li><li>右子树的节点 right</li><li>是否已经赋值 have_value（对应题目中的如果某个节点给出超过一次，应当输出 -1）</li></ul><p>由此可得以下代码：</p><pre><code class="cpp">struct Node {  bool have_value;  int v;  Node *left, *right;  Node(): have_value(false), left(NULL), right(NULL) {}};</code></pre><blockquote><p>由于二叉树是递归定义的，其左右子节点类型都是“指向节点类型的指针”。换句话说，如果节点的类型为 <code>Node</code>，则左右子节点的类型都是 <code>Node *</code>。</p><p>每次需要一个新的 <code>Node</code> 时，都要用 <code>new</code> 运算符申请内存，并执行构造函数。下面把申请新节点的操作封装到 <code>newnode</code> 函数中：</p></blockquote><pre><code class="cpp">Node* newnode() {  return new Node();}</code></pre><hr><p>接下来是在 <code>read_input</code> 中调用的 <code>addnode</code> 函数。它按照移动序列行走，目标不存在的时候调用 <code>newnode</code> 来创建新的节点：</p><pre><code class="cpp">void addnode(int v, char* s) {  int n = strlen(s);  Node *u = root;  for (int i = 0; i &lt; n; ++i) {    if (s[i] == &#39;L&#39;) {      if (u -&gt; left == NULL) {        u -&gt; left = newnode();      }      u = u -&gt; left;    } else if (s[i] == &#39;R&#39;) {      if (u -&gt; right == NULL) {        u -&gt; right = newnode();      }      u = u -&gt; right;    } // 忽略其他情况，即最后那个多余的右括号  }  if (u -&gt; have_value) {    failed = true; // 已经赋过值，表明输入有误  }  u -&gt; value = v;  u -&gt; have_value = true;}</code></pre><blockquote><p>这样一来，输入和建树部分就已经完成，接下来需要按照<strong>层次顺序</strong>遍历这棵树。此处使用一个<strong>队列</strong>来完成这个任务，<em>初始时只有一个根节点，然后每次取出一个节点，就把它的左右子节点（如果存在）放进队列</em>：</p></blockquote><pre><code class="cpp">bool bfs(vector&lt;int&gt;&amp; ans) {  queue&lt;Node *&gt; q;  ans.clear();  q.push(root);  while (!q.empty()) {    Node *u = q.front();    q.pop();    if (!u -&gt; have_value) {      failed = true; // 有节点没有被赋值过，表明输入有误      return false;    }    ans.push_back(u -&gt; value);    if (u -&gt; left != NULL) {      q.push(u -&gt; left);    }    if (u -&gt; right != NULL) {      q.push(u -&gt; right);    }  }  return true;}</code></pre><blockquote><p>这样遍历二叉树的方法称为<strong>宽度优先遍历</strong>。</p></blockquote><hr><p>为了避免<strong>内存泄露</strong>，我们需要释放使用过的内存空间：</p><pre><code class="cpp">void remove_tree(Node* u) {  if (u == NULL) {    return;  }  remove_tree(u -&gt; left);  remove_tree(u -&gt; right);  delete u;}</code></pre><blockquote><p>这样做虽然不会出现内存泄露，但可能会出现<strong>内存碎片</strong>。</p></blockquote><p>最终完整的代码：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define maxn 256 + 10using namespace std;struct Node {  bool have_value;  int value;  Node *left, *right;  Node(): have_value(false), left(NULL), right(NULL) {}};char s[maxn];bool failed;Node *root;Node* newnode() {  return new Node();}void addnode(int v, char* s) {  int n = strlen(s);  Node *u = root;  for (int i = 0; i &lt; n; ++i) {    if (s[i] == &#39;L&#39;) {      if (u -&gt; left == NULL) {        u -&gt; left = newnode();      }      u = u -&gt; left;    } else if (s[i] == &#39;R&#39;) {      if (u -&gt; right == NULL) {        u -&gt; right = newnode();      }      u = u -&gt; right;    }  }  if (u -&gt; have_value) {    failed = true;  }  u -&gt; value = v;  u -&gt; have_value = true;}bool read_input() {  failed = false;  root = newnode();  for (;;) {    if (scanf(&quot;%s&quot;, s) != 1) {      return false;    }    if(!strcmp(s, &quot;()&quot;)) {      break;    }    int v;    sscanf(&amp;s[1], &quot;%d&quot;, &amp;v);    addnode(v, strchr(s, &#39;,&#39;) + 1);  }  return true;}bool bfs(vector&lt;int&gt;&amp; ans) {  queue&lt;Node *&gt; q;  ans.clear();  q.push(root);  while (!q.empty()) {    Node *u = q.front();    q.pop();    if (!u -&gt; have_value) {      failed = true;      return false;    }    ans.push_back(u -&gt; value);    if (u -&gt; left != NULL) {      q.push(u -&gt; left);    }    if (u -&gt; right != NULL) {      q.push(u -&gt; right);    }  }  return true;}void remove_tree(Node* u) {  if (u == NULL) {    return;  }  remove_tree(u -&gt; left);  remove_tree(u -&gt; right);  delete u;}int main(void) {  while (read_input()) {    vector&lt;int&gt; ans;    bfs(ans);    if (failed) {      printf(&quot;-1\n&quot;);    } else {      for (int i = 0; i &lt; ans.size(); ++i) {        printf(&quot;%d&quot;, ans[i]);        if (i == ans.size() - 1) {          printf(&quot;\n&quot;);        } else {          printf(&quot; &quot;);        }      }    }    remove_tree(root);  }  return 0;}</code></pre><hr><p>同样，二叉树也可以用数组来实现。</p><p>首先还是给每个节点编号，但不是按照从上到下从左到右的顺序，而是按照节点生成的顺序。用计数器 <code>cnt</code> 表示已经存在的节点编号的最大值。</p><p>接着分别用 4 个数组 <code>left</code>, <code>right</code>, <code>value</code>, <code>have_value</code> 来代替结构体 <code>Node</code> 中的四个不同属性。</p><p>因此有：</p><pre><code class="cpp">const int root = 1;vector&lt;int&gt; left, right, value;vector&lt;bool&gt; have_value;int cnt;</code></pre><p>前面的 <code>remove_tree(root)</code> 和 <code>root = newnode()</code> 可以替换为 <code>newtree</code>：</p><pre><code class="cpp">void newtree() {  left.resize(1);  left.push_back(0);  right.resize(1);  right.push_back(0);  have_value.resize(1);  have_value.push_back(false);  value.resize(1);  value.push_back(0);   left[root] = right[root] = 0;  have_value[root] = false;  cnt = root;}</code></pre><p>注意这里因为我用的是 vector 数组，如果是普通数组需要使用 <code>memset</code> 来初始化数组。</p><p>接着 <code>newnode</code> 也改写为：</p><pre><code class="cpp">int newnode() {  int u = ++cnt;  left.resize(u + 1);  right.resize(u + 1);  have_value.resize(u + 1);  value.resize(u + 1);  left[u] = right[u] = 0;  have_value[u] = false;  return u;}</code></pre><p>如果是普通的数组这里不需要 resize。</p><p>接下来，把所有 <code>Node *</code> 类型改成 <code>int</code> 类型，然后把节点结构中的成员变量改成全局数组（例如，<code>u -&gt; left</code> 和 <code>u -&gt; right</code> 分别改成 <code>left[u]</code> 和 <code>right[u]</code>），除了 <code>char *</code> 外，整个程序就没有任何指针了：</p><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#define maxn 256 + 10using namespace std;const int root = 1;vector&lt;int&gt; left, right, value;vector&lt;bool&gt; have_value;int cnt;char s[maxn];bool failed;void newtree() {  left.resize(1);  left.push_back(0);  right.resize(1);  right.push_back(0);  have_value.resize(1);  have_value.push_back(false);  value.resize(1);  value.push_back(0);   left[root] = right[root] = 0;  have_value[root] = false;  cnt = root;}int newnode() {  int u = ++cnt;  left.resize(u + 1);  right.resize(u + 1);  have_value.resize(u + 1);  value.resize(u + 1);  left[u] = right[u] = 0;  have_value[u] = false;  return u;}void addnode(int v, char* s) {  int n = strlen(s);  int u = root;  for (int i = 0; i &lt; n; ++i) {    if (s[i] == &#39;L&#39;) {      if (left[u] == 0) {        left[u] = newnode();      }      u = left[u];    } else if (s[i] == &#39;R&#39;) {      if (right[u] == 0) {        right[u] = newnode();      }      u = right[u];    }  }  if (have_value[u]) {    failed = true;  }  value[u] = v;  have_value[u] = true;}bool read_input() {  failed = false;  for (;;) {    if (scanf(&quot;%s&quot;, s) !=  1) {      return false;    }    if (!strcmp(s, &quot;()&quot;)) {      break;    }    int v;    sscanf(&amp;s[1], &quot;%d&quot;, &amp;v);    addnode(v, strchr(s, &#39;,&#39;) + 1);  }  return true;}bool bfs(vector&lt;int&gt;&amp; ans) {  queue&lt;int&gt; q;  ans.clear();  q.push(root);  while (!q.empty()) {    int u = q.front();    q.pop();    if (!have_value[u]) {      failed = true;      return false;    }    ans.push_back(value[u]);    if (left[u] != 0) {      q.push(left[u]);    }    if (right[u] != 0) {      q.push(right[u]);    }  }  return false;}int main(void) {  newtree();  while (read_input()) {    vector&lt;int&gt; ans;    bfs(ans);    if (failed) {      printf(&quot;-1\n&quot;);    } else {      for (int i = 0; i &lt; ans.size(); ++i) {        printf(&quot;%d&quot;, ans[i]);        if (i == ans.size() - 1) {          printf(&quot;\n&quot;);        } else {          printf(&quot; &quot;);        }      }    }    newtree();  }  return 0;}</code></pre>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/01/30/trees-on-the-level/#disqus_thread</comments>
    </item>
    
    <item>
      <title>移动盒子</title>
      <link>https://stevearzh.github.io/2019/01/27/boxes-in-a-line/</link>
      <guid>https://stevearzh.github.io/2019/01/27/boxes-in-a-line/</guid>
      <pubDate>Sat, 26 Jan 2019 16:54:51 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;移动盒子（&lt;a href=&quot;https://uva.onlinejudge.org/external/126/12657.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Boxes in a Line, UVa 12657&lt;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>移动盒子（<a href="https://uva.onlinejudge.org/external/126/12657.pdf" target="_blank" rel="noopener">Boxes in a Line, UVa 12657</a>）</p><p>你有一行盒子，从左到右依次编号为 1, 2, 3, …, n。可以执行以下 4 种指令：</p><ul><li><p>1 X Y 表示把盒子 X 移动到盒子 Y 左边（如果 X 已经在 Y 的左边则忽略此指令）。</p></li><li><p>2 X Y 表示把盒子 X 移动到盒子 Y 右边（如果 X 已经在 Y 的右边则忽略此指令）。</p></li><li><p>3 X Y 表示交换盒子 X 和 Y 的位置。</p></li><li><p>4 表示反转整条链。</p></li></ul><p>指令保证合法性，即 X 不等于 Y。例如，当 n=6 时在初始状态下执行 1 1 4 后，盒子序列为 2 3 1 4 5 6。接下来执行 2 3 5，盒子序列变成 2 1 4 5 3 6。再执行 3 1 6，得到 2 6 4 5 3 1。最终执行 4，得到 1 3 5 4 6 2。</p><p>输入包含不超过 10 组数据，每组数据第一行为盒子个数 n 和指令条数 m（1 ≤ n, m ≤ 100000），以下 m 行每行包含一条指令。每组数据输出一行，即所有奇数位置的盒子编号之和。位置从左到右编号为 1~n。</p><p>样例输入：</p><blockquote><p>6 4</p><p>1 1 4</p><p>2 3 5</p><p>3 1 6</p><p>4</p><p>6 3</p><p>1 1 4</p><p>2 3 5</p><p>3 1 6</p><p>100000 1</p><p>4</p></blockquote><p>样例输出：</p><blockquote><p>Case 1: 12</p><p>Case 2: 9</p><p>Case 3: 2500050000</p></blockquote></blockquote><hr><p>首先肯定的是：单纯用数组来保存并实现这个过程，是不行的，肯定会超时。但如果像之前<a href="/2019/01/25/broken-keyboard/">破损的键盘</a>那样使用单向（数组）链表，似乎又不够，要怎么办呢？</p><blockquote><p>解决方案是采用<strong>双向链表</strong>：用 left[i] 和 right[i] 分别表示编号为 i 的盒子左边和右边的盒子编号（如果是 0，表示不存在），则下面的过程可以让两个节点相互连接：</p></blockquote><pre><code class="c">void link(int L, int R) {  right[L] = R;  left[R] = L;}</code></pre><blockquote><p><em>在双向链表这样复杂的链式结构中，往往会编写一些辅助函数用来设置链式关系。</em></p></blockquote><p>(关于基于数组实现的链表与基于指针实现的链表之间的异同，请参考<a href="/2019/01/25/broken-keyboard/">破损的键盘</a>。)</p><hr><p>举例来描述以上代码所展现的过程：</p><p>假设有两段双向链表（或者一段双向链表上的两截）,其中一段双向链表包含从左往右顺序为 a、X、b 的三个节点，另一段包含从左往右顺序为 u、Y、v 的三个节点，如下图所示：</p><p><img src="/img/boxes-in-a-line/IMG_1-1.png" alt=""></p><p>此时想要连接 L、R 节点，则需要将 L 节点的右侧指向 R 节点（<code>right[L] = R;</code>），将 R 节点的左侧指向 L 节点（<code>left[R] = L;</code>），如下图所示：</p><p><img src="/img/boxes-in-a-line/IMG_1-2.png" alt=""></p><hr><blockquote><p>有了这个代码，可以先记录好操作之前 X 和 Y 两边的节点，然后用 link 函数按照某种顺序把它们连起来。操作 4 比较特殊，为了避免一次修改所有元素的指针，此处增加一个标记 inv，表示有没有执行过操作 4（如果 inv=1 时再执行一次操作 4，则 inv 变为 0）。这样，当 op 为 1 和 2 且 inv=1 时，只需把 op 变成 3-op（注意操作 3 不受 inv 影响）即可。最终输出时要根据 inv 的值进行不同处理。</p><p><em>如果数据结构上的某一个操作很耗时，有时可以用加标记的方式处理，而不需要真的执行那个操作。但同时，该数据结构的所有其他操作都要考虑这个标记。</em></p></blockquote><p>这个<strong>加标记而非真的去执行操作</strong>的行为，特别像高中物理老师教给我们的一个方法：在计算求值的过程中，保留变量的符号，不要立刻代入值进行计算；到计算最终结果的那步，有些变量是可以（分子分母）约分掉的。</p><hr><p>可以发现：在上述的 link 操作中，在 L、R 相连之后，原先 L 节点的右节点 b，以及原先 R 节点的左节点 u，已经不再在新的 a-L-R-v 双向链表段中了（虽然它们还指向这段链表）。</p><p><img src="/img/boxes-in-a-line/IMG_1-3.png" alt=""></p><p>并且 a-L-R-v 链表段也<em>并非</em>题目的 op-1 的目标结果，在 op-1 执行过后的链表段实际上应该是 u-L-R-v。那么要怎么做呢？</p><p>分三步：</p><p>(1) 第一步，连接 L 节点左边的节点 a 与 L 右边的节点 b，保证原先 L 所在链表段的连接性（或者说，把节点 L 从 L 所在链表段中删除）：<code>link(a, b);</code></p><p><img src="/img/boxes-in-a-line/IMG_2-1.png" alt=""></p><p style="text-align: center; font-size: 0.75em;">link(a, b);</p><p>(2) 第二步，连接 R 节点左边的节点 u 与 L 节点：<code>link(u, L);</code></p><p><img src="/img/boxes-in-a-line/IMG_2-2.png" alt=""></p><p style="text-align: center; font-size: 0.75em;">link(u, L);</p><p>(3) 第三部，连接 L 节点与 R 节点：<code>link(L, R);</code></p><p><img src="/img/boxes-in-a-line/IMG_2-3.png" alt=""></p><p style="text-align: center; font-size: 0.75em;">link(L, R);</p><p>op-2 的操作过程与上述 op-1 的操作过程类似，在这里不再复述。</p><hr><p>最终代码如下：</p><pre><code class="c">#include&lt;cstdio&gt;#define maxn 100000 + 10int left[maxn], right[maxn];void swap(int &amp;a, int &amp;b) {  int t = a;  a = b;  b = t;}void link(int L, int R) {  right[L] = R;  left[R] = L;}int main(void) {  int m, n, kase = 0;  while (scanf(&quot;%d%d&quot;, &amp;n, &amp;m) == 2) {    for (int i = 1; i &lt;= n; ++i) {      left[i] = i - 1;      right[i] = (i + 1) % (n + 1);    }    right[0] = 1;    left[0] = n;    int op, X, Y, inv = 0;    while (m--) {      scanf(&quot;%d&quot;, &amp;op);      if (op == 4) {        inv = !inv;      } else {        scanf(&quot;%d%d&quot;, &amp;X, &amp;Y);        if (op == 3 &amp;&amp; right[Y] == X) {          swap(X, Y);        }        if (op != 3 &amp;&amp; inv) {          op = 3 - op;        }        if (op == 1 &amp;&amp; X == left[Y]) {          continue;        }        if (op == 2 &amp;&amp; X == right[Y]) {          continue;        }        int LX = left[X], RX = right[X], LY = left[Y], RY = right[Y];        if (op == 1) {          link(LX, RX);          link(LY, X);          link(X, Y);        } else if (op == 2) {          link(LX, RX);           link(X, RY);          link(Y, X);        } else if (op == 3) {          if (right[X] == Y) {            link(LX, Y);            link(Y, X);            link(X, RY);          } else {            link(LX, Y);            link(Y, RX);            link(LY, X);            link(X, RY);          }        }      }    }    int b = 0;    long long ans = 0;    for (int i = 1; i &lt;= n; ++i) {      b = right[b];      if (i % 2 == 1) {        ans += b;      }    }    if (inv &amp;&amp; n % 2 == 0) {      ans = (long long)n * (n + 1) / 2 - ans;    }    printf(&quot;Case %d: %lld\n&quot;, ++kase, ans);  }  return 0;}</code></pre><p>针对 Case 1，加入调试语句 <code>printf</code> 打印循环过程中的变量：</p><p><img src="/img/boxes-in-a-line/IMG_3.png" alt=""></p><p>可以相较上述过程进行验证。</p><hr><p>因为最终代码是书上提供的样例代码（运行测试没有问题），有几点疑问：</p><p>(1) 为什么当 <code>op == 3 &amp;&amp; right[Y] == X</code> 的时候(…aYXb…)，第 40 行代码使用了 <code>swap(X, Y);</code>，而非使用以下步骤？</p><pre><code class="c">if (op == 3 &amp;&amp; right[Y] == X) {  link(LY, X);  link(X, Y);  link(Y, RX);}</code></pre><p>（感觉这里 swap 操作的消耗和三次 link 操作的消耗实际上是差不多的）</p><p>(2) 为什么第 67~69 行代码，在 <code>op == 3 &amp;&amp; right[X] == Y</code> 的时候(…aXYb…)没有像第 40 行代码一样 <code>swap(X, Y);</code>？</p><p>(3) 为什么第 71~74 行代码，在 <code>op == 3</code> 的时候(…a…X…b…, …u…Y…v…)没有像第 40 行代码一样使用 <code>swap(X, Y);</code>？</p><p>(4) 是不是只有 X、Y 相邻的时候才能 swap 呢？</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/01/27/boxes-in-a-line/#disqus_thread</comments>
    </item>
    
    <item>
      <title>破损的键盘</title>
      <link>https://stevearzh.github.io/2019/01/25/broken-keyboard/</link>
      <guid>https://stevearzh.github.io/2019/01/25/broken-keyboard/</guid>
      <pubDate>Fri, 25 Jan 2019 13:43:20 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;破损的键盘（&lt;a href=&quot;https://uva.onlinejudge.org/external/119/11988.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Broken Keyboard(a.k.a. Bei
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>破损的键盘（<a href="https://uva.onlinejudge.org/external/119/11988.pdf" target="_blank" rel="noopener">Broken Keyboard(a.k.a. Beiju Text), UVa 11988</a>）</p><p>你有一个破损的键盘。键盘上的所有键都可以正常工作，但有时 Home 键或者 End 键会自动按下。你并不知道键盘存在这一问题，而是专心地打稿子，甚至连显示器都没打开。当你打开显示器之后，展现在你面前的是一段悲剧的文本。你的任务是在打开显示器之前计算出这段悲剧文本。</p><p>输入包含多组数据。每组数据占一行，包含不超过 100000 个字母、下划线、字符 “[” 或者 “]”。其中字符 “[” 表示 Home 键，“]” 表示 End 键。输入结束标志为文件结束符（EOF）。输入文件不超过 5MB。对于每组数据，输出一行，即屏幕上的悲剧文本。</p><p>样例输入：</p><blockquote><p>This_is<em>a</em>[Beiju]_text</p><p>[[]][][]Happy_Birthday_to_Tsinghua_University</p></blockquote><p>样例输出：</p><blockquote><p>BeijuThis_is_a__text</p><p>Happy_Birthday_to_Tsinghua_University</p></blockquote></blockquote><hr><p>这是一道书上的例题。拿道题后首先的想法自然是：用一个（char 类型的）数组来保存输入文本，然后再用一个变量（int 类型）来保存光标的位置，当输入新的字符的时候相当于在数组中插入一个字符（如果是在头部位置则需要将数组的所有元素后移）。</p><p>这种方法在理想情况下（没有触发 “[” 以及 “]” 时）的时间复杂度为 O(n)，但是在最坏情况下（每隔 t 次输入就会触发 “[”，t 很小）的时间复杂度为 O(n^2)。</p><p>很明显还有更好的方法 —— 链表。</p><hr><p>如果是基于指针实现的链表：</p><pre><code class="c">typedef struct List {  char value;  struct List *next;} List;</code></pre><p>那么也就没有写这篇笔记的必要了。</p><p>在这里引用书上的注解：</p><blockquote><p><em>读者可能在其他数据结构书中见过基于指针的链表实现方式，但是链表并<strong>不一定</strong>要用指针。</em></p></blockquote><p>那么还有什么办法呢？答案是：基于数组实现的链表。</p><blockquote><p>每输入一个字符就把它存起来，设输入字符串是 s[1~n]，则可以用 next[i] 表示在当前显示屏中 s[i] 右边的字符编号（即在 s 中的下标）。</p><p>为了方便起见，假设字符串 s 的最前面还有一个虚拟的 s[0]，则 next[0] 就可以表示显示屏中最左边的字符。再用一个变量 cur 表示光标位置：即当前光标位于 s[cur] 的右边。cur=0 说明光标位于 “虚拟字符” s[0] 的右边，即屏幕的最左边。</p><p>为了移动光标，还需要用到一个变量 last 表示显示屏的最后一个字符是 s[last]。</p></blockquote><hr><p>个人理解：</p><ul><li>实际上这里的 next[0] 用基于指针的链表（以下简称指针链表）来表述的话，就是链表之前的 head 指针</li><li>next[0] 里存储的值相当于 head 指针指向的目标；</li><li>同样，其余的 next[i] 里存储的值也表示了 i 节点（Node）所指向的节点；</li><li>next 末尾元素为 0，对应指针链表的 tail 指针，或者说是 ‘\0’。</li></ul><p>当数据存入不同链表后，可以用以下图来表示：</p><p><img src="/img/broken-keyboard/IMG_1.png" alt=""></p><p style="text-align: center; font-size: 0.75em;">当输入 This 后，链表指针（上）与数组指针（下）</p><p>到这里，我们已经理清了数组链表（相对于指针链表）<strong>存储</strong>元素的方式。下一步，就该探索如何向数组链表中插入新的元素了。</p><p>我们还是以指针链表来举例说明这一过程：</p><p>(0) 假定有一个空的指针链表，记其头部指针为 h（next[0]），当前指针为 c（cur），末尾的指针为 t（last），现在准备向这个链表中插入新的节点 i，其存储的值为 “T”；</p><p><img src="/img/broken-keyboard/IMG_2-1.png" alt=""></p><p>(1) 将指针 i 指向指针 c 所指向的节点：<code>i -&gt; next = c -&gt; next</code>；</p><p><img src="/img/broken-keyboard/IMG_2-2.png" alt=""></p><p style="text-align: center; font-size: 0.75em;">i -&gt; next = c -&gt; next</p><p>(2) 将指针 c 指向节点 i：<code>c -&gt; next = i</code>；</p><p><img src="/img/broken-keyboard/IMG_2-3.png" alt=""></p><p style="text-align: center; font-size: 0.75em;">c -&gt; next = i</p><p>(3) 将指针 c 移动到指针 c 所指向的节点：<code>c = c -&gt; next</code> 或者 <code>c = i</code>；</p><p><img src="/img/broken-keyboard/IMG_2-4.png" alt=""></p><p style="text-align: center; font-size: 0.75em;">c = c -&gt; next</p><p>这样我们就完成了在指针链表上插入新节点的全部过程。把上面的 1 ~ 3 步用基于数组链表的代码来描述的话，如下所示：</p><pre><code class="c">next[i] = next[cur];next[cur] = i;cur = i;</code></pre><p>考虑到 last 指向最后一个元素，可以这样来保证：</p><pre><code class="c">if (cur == last) {  last = i;}</code></pre><p>当 Home 键触发的时候，将 cur 移动到链表的头部：</p><pre><code class="c">cur = 0;</code></pre><p>当 End 键触发的时候，将 cur 移动到链表的尾部：</p><pre><code class="c">cur = last;</code></pre><p>补全完整的代码如下所示：</p><pre><code class="c">#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxn = 100000 + 5;int last, cur, next[maxn];char s[maxn];int main(void) {  while (scanf(&quot;%s&quot;, s + 1) == 1) {    int n = strlen(s + 1);    last = cur = 0;    next[0] = 0;    for (int i = 1; i &lt;= n; ++i) {      char ch = s[i];      if (ch == &#39;[&#39;) {        cur = 0;      } else if (ch == &#39;]&#39;) {        cur = last;      } else {        next[i] = next[cur];        next[cur] = i;        if (cur == last) {          last = i;        }        cur = i;      }    }    for (int i = next[0]; i != 0; i = next[i]) {      printf(&quot;%c&quot;, s[i]);    }    printf(&quot;\n&quot;);  }  return 0;}</code></pre><p>加入调试语句 <code>printf</code> 打印循环过程中的变量：</p><p><img src="/img/broken-keyboard/IMG_3.png" alt=""></p><p>可以相较前文代码与图片进行验证。</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/01/25/broken-keyboard/#disqus_thread</comments>
    </item>
    
    <item>
      <title>ZigZag Conversion</title>
      <link>https://stevearzh.github.io/2019/01/06/leetcode-zigzag-conversion/</link>
      <guid>https://stevearzh.github.io/2019/01/06/leetcode-zigzag-conversion/</guid>
      <pubDate>Sun, 06 Jan 2019 15:56:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;刷 LeetCode 的时候遇到一道题 &lt;a href=&quot;https://leetcode.com/problems/zigzag-conversion/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;6. ZigZag Conversion&lt;/a&gt;，题目
        
      
      </description>
      
      <content:encoded><![CDATA[<p>刷 LeetCode 的时候遇到一道题 <a href="https://leetcode.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. ZigZag Conversion</a>，题目在这里就不复述。</p><p>最开始我以为会有什么巧妙的方法（比如 O(logN)）来解决这道题，新建空文档把样例写下来研究了老半天。</p><p><img src="/img/leetcode-zigzag-conversion/IMG_01.png" alt=""></p><p>结果一点思路也没有，就打开了题目的 <a href="https://leetcode.com/problems/zigzag-conversion/solution/" target="_blank" rel="noopener">solution</a>，然后我看到了这句话：</p><blockquote><p>Iterate through s from left to right, appending each character to the appropriate row. The appropriate row can be tracked using two variables: the current row and the current direction.</p></blockquote><p>好了不用看了，原来就是硬解。在初始的时候设定 n 个数组用来保存对应行的字符串，然后遍历就行。最终还是个 O(n) 的解法。继续自己来吧。</p><hr><p>打开画图板实际操作一遍，可以发现还是有规律的：</p><p><img src="/img/leetcode-zigzag-conversion/IMG_02.png" alt=""></p><p>实际上将初始字符串 s 保存到不同的 n 个结果数组中去，这个过程可以划分为 VVVVV… 的 k 个步骤，每个步骤之间都是一个重复的过程。</p><p>从左往右循环的过程中，横坐标 i 是持续增大的，难点在于纵坐标 j，它是先从 0 增大到 n - 1，再减小到 0，再增大到 n - 1… 这里需要用抽象的逻辑语言（代码）来描述。</p><p><img src="/img/leetcode-zigzag-conversion/IMG_03.png" alt=""></p><p>继续观察并计算，可以发现控制 j 值增减的关键在于 Z 字型的<strong>边缘临界点</strong>，其值如下：</p><p><img src="/img/leetcode-zigzag-conversion/IMG_04.png" alt=""></p><p>三个临界点，以及 j 值的增减过程可以表示为：</p><blockquote><p>k <em> (2 </em> n - 2)</p><p>(当 i 处于这个区间时，j 的值持续增大)</p><p>(n - 1) + k <em> (2 </em> n - 2)</p><p>(当 i 处于这个区间时，j 的值持续减小)</p><p>(k + 1) <em> (2 </em> n - 2)</p><p>(下一个阶段)</p><p> k ∈ [0, 1, 2, …]</p></blockquote><p> 至此，可以得到最终的代码：</p><pre><code class="python3"> class Solution:    def convert(self, s, numRows):        &quot;&quot;&quot;        :type s: str        :type numRows: int        :rtype: str        &quot;&quot;&quot;        if numRows == 0:            return &#39;&#39;        if numRows == 1:            return s        tmp = dict()        for i in range(numRows):            tmp[i] = &#39;&#39;        [j, k] = [0, 0]        for i in range(len(s)):            tmp[j] += s[i]            if i &gt;= (k + 1) * (2 * numRows - 2):                k += 1            if i &lt; (numRows - 1) + k * (2 * numRows - 2):                j += 1            else:                j -= 1        result = &#39;&#39;        for i in range(numRows):            result += tmp[i]        return result</code></pre><p><img src="/img/leetcode-zigzag-conversion/IMG_05.png" alt=""></p><p>提交通过！</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2019/01/06/leetcode-zigzag-conversion/#disqus_thread</comments>
    </item>
    
    <item>
      <title>改装 iPod Classic</title>
      <link>https://stevearzh.github.io/2018/01/20/ipod-classic-enhancing/</link>
      <guid>https://stevearzh.github.io/2018/01/20/ipod-classic-enhancing/</guid>
      <pubDate>Sat, 20 Jan 2018 14:53:29 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;这是我在 12 年还是 13 年入手的 ipod classic，已经停产多年了，但外观还是非常喜欢。不过 16 年底的时候疑因为硬盘损坏（不能往里面存放歌曲）导致 classic 无法使用，然后就放角落里好长时间没动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/ipod
        
      
      </description>
      
      <content:encoded><![CDATA[<p>这是我在 12 年还是 13 年入手的 ipod classic，已经停产多年了，但外观还是非常喜欢。不过 16 年底的时候疑因为硬盘损坏（不能往里面存放歌曲）导致 classic 无法使用，然后就放角落里好长时间没动。</p><p><img src="/img/ipod-classic/IMG_1.jpg" alt=""></p><p>直到上周天，在网上看到了有给 classic 换 SSD 的消息，就准备自己也尝试下给 classic 升级。马上就在淘宝下单，买了后盖（原来的后盖已经磨花得不行了）、撬棍螺丝刀、SSD 以及电池。</p><p><img src="/img/ipod-classic/IMG_2.png" alt=""></p><p>应该是因为有电池的原因不能走空运，直到昨天（周五）下午快递才送到。恰巧昨天上午头疼请假，中午就回家了。今天下午专程跑到公司去把配件取了回来。</p><p><img src="/img/ipod-classic/IMG_3.jpg" alt=""></p><p>之前和公司的大佬聊过我要改装这事儿，大佬说他的朋友之前也改装过，拆的时候非常不好拆，告诫我：</p><blockquote><p><strong>要从 classic 左边开始撬，因为排线在右边</strong></p></blockquote><p>然后我撬的时候发现… 果然真 TM 难撬，费了九牛二虎之力，那三个绿的塑料撬棍都撬折了。最后，靠那个金属撬棍才给硬撬开。看着那惨不忍睹的后盖还有鼓包的电池，心里暗自庆幸还好买了新的。</p><p><img src="/img/ipod-classic/IMG_4.jpg" alt=""></p><p>（事后证明我没有…）小心翼翼地把后盖上的电池、排线依次取下。准备换硬盘的时候发现，硬盘的四个角上都是五个棱的 * 状凹槽，而淘宝买来螺丝刀是个十字形状的。心里暗叫一声不妙，开始翻箱倒柜找合适的螺丝刀，当然没有找到… 依次尝试用六个棱的、十字的、一的螺丝刀去拧开，未果。</p><p>抱着试一试的心态在网上搜索，结果搜到了这篇文章 <a href="https://www.ifixit.com/Guide/Installing-iPod-Classic-Hard-Drive/564" target="_blank" rel="noopener">iPod Classic Hard Drive Replacement</a>。</p><p><img src="/img/ipod-classic/IMG_5.png" alt=""></p><p>难度系数：Very difficult… Are you kidding me?!</p><p>依次看，直到<a href="https://www.ifixit.com/Guide/Installing-iPod-Classic-Hard-Drive/564#s2735" target="_blank" rel="noopener">第 24 步</a>，可以发现其实不需要把硬盘上的螺丝卸下来，那是硬盘的一部分。把硬盘翻过来背面有个小齿装的卡槽，用塑料撬棍轻轻拨开之后就可以顺利得把硬盘取下来了。接着更换 ssd，安装排线、新的电池到新的后盖上。</p><p><img src="/img/ipod-classic/IMG_6.jpg" alt=""></p><p>在合上后盖之前，我提前抱着忐忑的心态接通了电源，并通过 usb 连接到了我的电脑。好在 iTunes 立刻识别了 classic 并开始下载固件恢复出厂设置。</p><p><img src="/img/ipod-classic/IMG_7.jpg" alt=""></p><p><img src="/img/ipod-classic/IMG_8.png" alt=""></p><p><img src="/img/ipod-classic/IMG_9.png" alt=""></p><p><img src="/img/ipod-classic/IMG_10.png" alt=""></p><p>大功告成！我捏紧了后盖，把保护膜撕了下来。</p><p><img src="/img/ipod-classic/IMG_11.jpg" alt=""></p><p>打扫战场，祭奠逝去的残骸：</p><p><img src="/img/ipod-classic/IMG_12.jpg" alt=""></p><p>最后安装好透明外壳，从网易音乐的电台下载了大爱的<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E5%BA%A6%E7%A5%9E%E5%89%912" target="_blank" rel="noopener">异度之刃 2</a>的 ED —— <a href="http://music.163.com/#/program?id=1367121473" target="_blank" rel="noopener">One Last You</a> 到 classic，插上耳机，准备好好欣赏一下。</p><p><img src="/img/ipod-classic/IMG_13.jpg" alt=""></p><p>结果发现悲剧的事情了 —— 右声道没有声音… 耳机是好的，接电脑是没有问题的。赶紧询问公司大佬北京哪里能修 classic，大佬让我在淘宝搜一下。发现有几家中关村的店，准备明天白天过去看下…</p><h4 id="后记："><a href="#后记：" class="headerlink" title="后记："></a>后记：</h4><p>下午拿去中关村修了下，换了排线，外加 1400 mAh 的改装电池（华为手机电池）。修理的大叔总共收了我 180 块钱，讨价还价未果…</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2018/01/20/ipod-classic-enhancing/#disqus_thread</comments>
    </item>
    
    <item>
      <title>collision writeup</title>
      <link>https://stevearzh.github.io/2018/01/14/pwnablekr-collision-writeup/</link>
      <guid>https://stevearzh.github.io/2018/01/14/pwnablekr-collision-writeup/</guid>
      <pubDate>Sat, 13 Jan 2018 16:57:52 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;无意中发现了 &lt;a href=&quot;http://pwnable.kr/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pwnable.kr&lt;/a&gt; 这个 CTF 刷题网站，虽然 UI 看着有些过时，不过主题还是挺 RPG 风的。&lt;/p&gt;
&lt;p&gt;&lt;img sr
        
      
      </description>
      
      <content:encoded><![CDATA[<p>无意中发现了 <a href="http://pwnable.kr/" target="_blank" rel="noopener">pwnable.kr</a> 这个 CTF 刷题网站，虽然 UI 看着有些过时，不过主题还是挺 RPG 风的。</p><p><img src="/img/pwnablekr/overview.png" alt=""></p><hr><p>第一道题 fd 可以说是个 demo，很容易就可以完成；然后就可以看第二题 collision 了，题目描述如下：</p><blockquote><p>Daddy told me about cool MD5 hash collision today.<br>I wanna do something like that too!</p><p>ssh col@pwnable.kr -p2222 (pw:guest)</p></blockquote><p>首先 ssh 到 server，输入 <code>ls</code> 可以发现 <em>flag</em> 就在当前目录下，不过 <code>cat flag</code> 却发现没有查看的权限。</p><p><img src="/img/pwnablekr/collision-one.png" alt=""></p><p>那么只能从 <code>col.c</code> 入手了，通过 <code>cat</code> 查看代码如下：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){    int* ip = (int*)p;    int i;    int res=0;    for(i=0; i&lt;5; i++){      res += ip[i];    }    return res;}int main(int argc, char* argv[]){    if(argc&lt;2){      printf(&quot;usage : %s [passcode]\n&quot;, argv[0]);      return 0;    }    if(strlen(argv[1]) != 20){      printf(&quot;passcode length should be 20 bytes\n&quot;);      return 0;    }    if(hashcode == check_password( argv[1] )){      system(&quot;/bin/cat flag&quot;);      return 0;    }    else      printf(&quot;wrong passcode.\n&quot;);    return 0;}</code></pre><p>从源码分析易知：</p><ol><li>程序接受一个<strong>长度为 20 的字符串</strong>作为参数；</li><li>通过函数 <code>check_password</code> 对该参数进行某种转化，使得输出值为 <code>0x21DD09EC</code></li></ol><hr><p>分析函数 <code>check_password</code>，从函数定义的第 1 行：</p><pre><code class="c">unsigned long check_password(const char* p){</code></pre><p>可知，函数接受一个 <code>char</code> 类型的指针（即字符串）作为参数，返回值为 <code>unsigned long int</code>。接着我们来看函数定义的第 2 行：</p><pre><code class="c">int* ip = (int*)p;</code></pre><p>这是一个赋值表达式，等号左边定义了一个 <code>int</code> 类型的指针变量 <code>ip</code>，等号右侧发生了显示的<strong>类型转换</strong>，传入函数的参数 <code>p</code> 由 <code>char</code> 类型的指针转换为了 <code>int</code> 类型的指针。</p><p>通过 <code>uname -a</code> 查看 server 的操作系统版本：</p><p><img src="/img/pwnablekr/collision-two.png" alt=""></p><p>可知，程序运行于 64 位的操作系统，即 1 个 <code>int</code> 变量在内存中占据 4 <code>byte</code> 的空间。也就是说上述的显示类型转换使得变量发生了如下图所示的转换：</p><p><img src="/img/pwnablekr/collision-three.jpg" alt=""></p><p>即 <code>int</code> 类型的指针 <code>ip</code> 上存储了 <code>20 / 4 = 5</code> 个 int 类型的变量。（确切的说是可以从 <code>int</code> 类型的指针变量 <code>ip</code> 向后偏移 4 次，包括 <code>ip</code> 本身，共读取 5 个 <code>int</code> 类型变量的地址）</p><p>后续函数 <code>check_password</code> 剩余的部分将这 5 个变量相加并将最终结果返回。</p><hr><p>为了进一步探究程序运行过程中的细节，在本地创建 <code>col.c</code> 文件，并将 server 端 <code>col.c</code> 源码略作修改如下：</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){    int* ip = (int*)p;        int i;    int res=0;    for(i=0; i&lt;5; i++){        res += ip[i];        printf(&quot;ip[%d]: 0x%x\n&quot;, i, ip[i]);    }    return res;}int main(int argc, char* argv[]){    printf(&quot;result: 0x%x\n&quot;, check_password(argv[1]));    printf(&quot;wanted: 0x%x\n&quot;, hashcode);    return 0;}</code></pre><p>并运行：</p><p><img src="/img/pwnablekr/collision-four.png" alt=""></p><p>观察并分析可知，<code>char</code> 在转换为 <code>int</code> 时首先按照 ASCII 码转换为十六进制的值，接着按照<strong>从右往左</strong> 4 个 1 组的方式拼接出 1 个 int 变量。实际发生的转换如下图所示：（当然，更好的调试方式是使用 <strong>gdb</strong> 来调试。）</p><p><img src="/img/pwnablekr/collision-five.jpg" alt=""></p><p>查阅维基百科 <a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a> 词条可知，可见 ASCII 码的范围是 <code>0x20 ~ 0x7e</code>。在本地编写 <code>col.py</code> 脚本如下：</p><pre><code class="python">#!/usr/bin/env python3target = &quot;0x21dd09ec&quot;# range is 0x20 ~ 0x7emin = 0x20max = 0x7earr = [min] * 4 * 5def check_password(source):    arr = list(source)    result = 0    for i in range(5):        result += arr[(i-1) * 4] \            + arr[(i-1) * 4 + 1] * 0x100 \            + arr[(i-1) * 4 + 2] * 0x10000 \            + arr[(i-1) * 4 + 3] * 0x1000000    return &quot;0x&quot; + &quot;&quot;.join(list(hex(result))[-8:])def increase_arr(source):    arr = list(source)    i = 0    while True:        if i &gt;= len(arr):            break        if (arr[i] == max):            arr[i] = min            i += 1        else:            arr[i] += 1            break    return arrwhile check_password(arr) != target:    print(check_password(arr))    arr = increase_arr(arr)print(&#39;finished!&#39;)print(&quot;&quot;.join(map(lambda num: chr(num), arr)))</code></pre><p>运行脚本，会发现很长时间都无法得到想要的结果：</p><p><img src="/img/pwnablekr/collision-seven.png" alt=""></p><p>再次调用本地编译好的 <code>col</code> 并观察，可知函数 <code>check_password</code> 在执行过程中发生了溢出行为，最终结果只保留了最后 8 位结果。将 <code>col.py</code> 脚本中的循环初始值 <code>arr</code> 修改为更接近最终结果的值：</p><pre><code class="python">arr = [0x6c] * 4 * 5</code></pre><p>并重新运行，片刻后可得到最终结果：</p><p><img src="/img/pwnablekr/collision-eight.png" alt=""></p><p>使用这串字符串在 server 中执行 <code>col</code> 便可以拿到 flag 了：</p><p><img src="/img/pwnablekr/collision-nine.png" alt=""></p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2018/01/14/pwnablekr-collision-writeup/#disqus_thread</comments>
    </item>
    
    <item>
      <title>猫眼离职记</title>
      <link>https://stevearzh.github.io/2017/09/16/how-i-left-maoyan/</link>
      <guid>https://stevearzh.github.io/2017/09/16/how-i-left-maoyan/</guid>
      <pubDate>Sat, 16 Sep 2017 12:07:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;事情要从六月底的某个周五说起。&lt;/p&gt;
&lt;p&gt;晚上六点半左右，波哥，我当时的 leader，在大象（内部 IM）上告诉我有半小时的空闲时间，可以和我聊聊，因为我之前多次找过他希望聊聊。&lt;/p&gt;
&lt;p&gt;找到就近的空闲会议室坐下来后，我开门见山的告诉波哥：希望晚上能够早些下班，
        
      
      </description>
      
      <content:encoded><![CDATA[<p>事情要从六月底的某个周五说起。</p><p>晚上六点半左右，波哥，我当时的 leader，在大象（内部 IM）上告诉我有半小时的空闲时间，可以和我聊聊，因为我之前多次找过他希望聊聊。</p><p>找到就近的空闲会议室坐下来后，我开门见山的告诉波哥：希望晚上能够早些下班，因为我下班回家后还会有自己的安排；不希望现在这样的<strong>被动加班</strong>（每天晚上八点半开日会，九点多甚至十点才能下班），尤其是在我工作照常完成的情况下，还得干等到日会结束。</p><p>波哥表示很惊讶，说：“我不太懂你们前端，团队的其他（后端）同学都表示项目完不成、时间不够，你还是第一个向我抱怨太闲的人，如果你的工作完成了，可以去看看项目的其他地方有没有工作可以去做。”（潜意思就是我的工作不饱和）“抱怨每个人都会，但我要的是解决方案。”</p><p>于是我就提出了我的建议：把每日例会改成早晨开，这样就可以早点下班了。同时也稍微抱怨了下没有加班费的问题。（每天八点后走有 30 块钱餐饮补助，但是得自己找发票）</p><p>波哥一口回绝，说不行，这属于倡导团队走向的问题。他问我：“你知道为什么我要把例会放到晚上八点半才开吗？每天开完会我们的后端都还会有一个技术分享会，当然了，你们前端从来就没参加过。这个其实是我希望大家能够主动或者被动的多学一些东西。人都是有惰性的，如果我不这样督促大家，团队是无法进步的。”</p><p>“还有工作时间问题。你刚入职的时候公司的 Q1 绩效你也参加了，每个人都会有考核。同样的，每个团队之间也会有竞争。”</p><p>“你知道咱们团队目前平均每天打卡时间是多少吗？10 个小时。你平均每天打卡时间只有 9 个小时。猫眼某些团队平均每天的打卡时间是达到了 11 个小时的。”</p><p>我点了点头，说我感觉不太适应团队的节奏，本来是想转岗去美团的其他部门的，但是没有找到合适的岗位，就决定不转了。</p><p>（其实这才是我“被离职”的真正原因，我解释下：Q1 之后我当时的组长就因为某些原因转岗去了美团基础架构组，而且大象的某些群组里也会有很多内部转岗之类的消息，使我以为转岗也属于美团的一种文化。于是我就拜托之前的组长、还有当时来美团面试的餐饮部门的前端 leader 打听下转岗的事情。这个 leader 表示没问题，同时也建议我找波哥谈谈。我当时没想太多，就找着谈了。但我也是在离职后才知道：得有部门接收你了，你才可以和 leader 摊牌。不然 leader 是可以整你的。即使你是抱着就事论事的态度，但 leader 不一定会。）</p><p>波哥这时已经有些不爽了，但当时我没发现，也没想到他会用绩效来整我。他缓缓说道：“团队里每个人的想法是不同的，目标也是不一样的，别人的目标和你的一定不相同。”</p><p>“其实互联网这个圈子很小的，有的人在北京混不下去了，就走了。等你干的久了，厉害了，你就会发现不管在哪都是这些人。”</p><p>（还在之后的周会上重复这句话了… 我没想到这是对我的一个威胁，让我在北京混不下去？？？不过确实美团混不下去了）</p><p>“我希望我的团队里都是厉害的人，所以我希望每个人都有相同的节奏。像你这样每天中午十一点半才来上班，对团队造成的影响是不好的，但同样如果有人八点半来上班我也是不满意的”</p><p>（我也没想到这是对我的最后通牒，或者劝退我也只是随便找个借口就行？当然，这是我唯一做的不对的地方，上班时间太晚。）</p><p>“你每天十一点半才来上班，电脑还没摸热就去吃中午饭了，然后回来睡个午觉就两点了。” “你还不睡午觉看电影，那天我坐在你旁边 XXX 的位置上，你就明目张胆的在那里看。”</p><p>…实际上是在看美剧，因为我怕打扰睡午觉的同学，就戴着耳机了，当时也没注意到波哥。我说：“不是午休时间吗，我觉得打打游戏、看看美剧没啥问题啊，很多同学包括你波哥不也会打打农药吗。而且我的工作是按时完成的啊？”</p><p>波哥呵呵一笑，说：“你在我这，甚至在你（新的）组长那里可以算是没有问题的。那你让别的同学怎么想，人是会说三道四的。”</p><p>“如果信息公开透明，自然不会有人说三道四了。”</p><p>波哥避开了这个话头，说：“你的组长也和我反映了，说你的工作确实完成的质量不错。我不是很懂前端，但像你之前提议的前端‘权限树’这种，不是挺好的吗？你任务完成后，可以尽量找点这种工作去做。你知道咱们团队有统计千行代码错误率这个事情吗？”</p><p>“知道，但是听组长说我们前端好像没弄这个东西？”</p><p>“弄了，所有上传到 git 仓库的代码都会有这个统计，你知道你们前端那边谁的错误率最高吗？”</p><p>我摇了摇头。</p><p>“XXX（这里称之为 X 同学吧）还有你的组长。”</p><p>我有点惊讶。</p><p>“当然了，这个也只是统计的一种手段，不能说明什么。人写的代码多/代码难，出错率当然就高了。就和统计打卡时间一样，你和 X 同学打卡时间一个倒数第一一个倒数第二。不过 X 同学最近好像来得也早一些了。”</p><p>（我更没想到这里会是和我的一种妥协？如果我妥协了，就拿 X 同学当典型了？？？但愿只是我的猜测吧，不过我走之前给 X 同学说了这个事情。）</p><p>……</p><p>谈话之后，生活照常继续。每天还是九点下班，我也还是每天十一点半才来上班。期间也有美团某部门的 leader 来找我画大饼，问我有没有兴趣加入。而我因为准备和猫眼另一个部门的前端大佬合作，在 Q3 弄一个微博舆情监控系统，谢绝了那个邀请。本来以为不会有什么变化，那次找波哥的谈话也只是小插曲罢了。</p><p>直到过了几天，系统提示我填写 Q2 季度绩效自评，我按照之前 Q1 的模式胡乱写了些交上去，心里想着这东西还真麻烦…</p><p>（说道 Q1 绩效，还有个搞笑的事情不得不提。因为当时我刚入职，很多业务不太熟悉，导致工作不能按时完成，还加过班。波哥看我很辛苦很努力的样子，还向上面提议给我发个最佳新人奖，结果要求入职满三个月才能发所以作罢…）</p><p>结果精彩的地方来了，在例行的季度谈话中，波哥和我的组长一脸严肃的找着我（白脸变黑脸），波哥说：“鉴于你对团队造成的不好的影响，（组织上）决定 Q2 绩效给你评 C，你有什么异议吗？”</p><p>我还是有点惊讶的，不过想想自己又不准备转岗了，还找了个有意思的项目去做，就不发表什么意见了吧，就说：“没有异议。”</p><p>波哥又说：“有什么想说的吗？我看你最近几天还是来这么晚，是不是不想干了？！”</p><p>（原来是想我自己提出离职的事，但我当时可没往这个方向想…)</p><p>我连忙说：“没有没有。”</p><p>这个时候组长又说话了：“早就让你对咱们现在这个项目做一些架构上的优化，你一直不做，你看 X 同学不就做的挺好。”</p><p>我说：“其实我反对为了所谓的优化而优化。因为咱们的项目还没有上线，优化的地方不一定是今后出问题的地方。在不顾及其他同学的情况下进行优化、引入新的技术栈其实是不对的…”</p><p>这个时候分明感受到了波哥鄙视的目光。</p><p>然后谈话就草草结束了… 我回去想了想，这样也不是事儿。机械地重复搬砖感觉也提升不了技术了，实在不行就去后端组写 Java 吧。也和玩儿的比较好的后端同学聊了聊，感觉可行。就在两天后又找波哥聊，提到了希望转岗去后端组的事情。</p><p>（估计本来是以为我要提离职的，结果我是提转岗去写 Java。）“你这个吧，事情比较麻烦…”</p><p>“你之前不是在周会也说了吗，说如果业务写烦了可以转去基础架构组，反过来也可以，说是鼓励转岗的”</p><p>“因为那是 Java 之间互相转。你知道咱们美团这边招技术岗实际是分四个方向的吗，前端、后端、测试还有运维。是哪个方向 offer 上就已经写死了。这种跨方向的转岗可能需要重新面试的，我当时面你的时候也没有面 Java 方面的问题”</p><p>“行啊，重新面试也没问题”</p><p>“这样吧，你找你的 HR 聊聊这个问题，看看她那边的意见。还有什么问题吗，我看你工作的也挺不开心的…”</p><p>“…没有了”</p><p>……</p><p>到了第二天早晨的谈话，HR 说：“听你的 leader 说你希望转岗去写 Java，能说说为什么吗？”</p><p>“是这样的，因为感觉现在前端这边感觉一直在重复机械地工作，想在我任务完成的基础上去接触一些 Java 方面的工作。”</p><p>“但是你 Q2 刚出来的绩效是 C，很不好啊？转岗的最基本要求的是工作优秀才可以的。你的工作非常不负责…”</p><p>“呃，绩效评 C 是 leader 说我对团队造成的影响不好，跟工作没有关系。”</p><p>“唔，你也知道自己对团队造成了很不好的影响了？你们每个人的打卡时间我这边都有关注的，我看你打卡时间都是十一点半左右对吧？” “没错。”</p><p>“因为我是新来的 HR，不太熟悉你们之前的状况。你是二月份来的对吧，也是项目组的第一个前端。”</p><p>本来我想说我之前那个组长的，不过想了想组长好像是个全栈，就点了点头：“是的。”</p><p>“谁给你面试的？”</p><p>“…选座交易组那边的 XXX（大佬）”</p><p>“你的试用期是半年，你还有一个月的时间。我们这边希望你能尽快发出离职申请，抓紧时间去找下一份机会，这样我会在你的离职信上写的好看一些（然而并没有好看什么的）。今天是周四，你的 last day 最迟是定在下周四，你选一天吧？”</p><p>被打了套组合拳，我当时有点蒙圈，就随口说了句：“那就下周四吧。”</p><p>“爽快，那你等下回去就尽快提离职申请吧”</p><p>“…等下，我刚才没理解清楚，是等下就要提离职，不是下周四提离职？”</p><p>“没错”</p><p>“还能往后推吗？”</p><p>“不行，” HR 冷着脸回到，“明天你就不用来公司，下周四来办手续就行，工资给你照常算。还有其他问题吗？”</p><p>“…没了”</p><p>……</p><p>回到工位后，不知道怎么提离职，就给 HR 发了条大象，HR 告诉我大象里就能提。找了半天才找到。提完离职后（还没审批完），发现有段改动的代码还没有提交，结果已经没有 push 权限了。就联系了组长，找他交接工作把改动过的文件拷贝给他。我问组长：“我的工作有问题吗，HR 说我工作方面很差。” 组长说：“我一直和波哥说你的工作完成的不错，甚至比某些个同学的效率还要高。HR 这只是找个名头而已。”</p><p>“哦…” (既然不是工作问题，那绩效评 C 就是价值观问题了吧，而且问猫眼呆了好多年的同事，绩效第一次评 C 就被劝退的没听说过)</p><p>“那我需要发离职邮件吗？” “发一下吧，记得写得漂亮点”</p><p>……</p><p>尽管下着暴雨，我也还是拖着一堆物品淋雨赶到地铁站。结果在地铁上，我发现 HR 在大象上给我发消息：“要不今天就把手续给你办了吧，省的你下周还得再跑一趟。你直接去找 XXX 同事就好，last day 给你写下周四…” 真没见过这么赶人走的，我回到：“不好意思，我已经撤了，还是下周四再办手续吧”</p><p>……</p><p>“基于职业生涯规划方面的原因，不能和大家共同走下去了…” 写邮件的同时，我也理解了之前组长的离职邮件</p><p>……</p><p>办完手续的当天，约了本来准备 Q3 共建项目的大佬聊了聊。大佬先问了我为什么没有联系转岗去他部门… 因为我以为猫眼不能内部转的，要不之前组长怎么去美团了。又和大佬聊了很多，包括职业生涯规划、人生规划等等，获益匪浅。</p><p>……</p><p>然而事情到这里并没有结束。就在我焦头烂额准备找工作的时候，boss 直聘上有消息来了，结果一看是美团金服的前端 leader，问我有没有兴趣去他们那里，和我详细说明了团队所做的事情还有技术架构等，感觉还不错，就约了时间见面聊。见面聊完后都感觉不错，leader 就让我回去等消息，说是要走人事那边的流程。</p><p>结果等了两三天还没消息，我就问 leader 还有戏吗，leader 说再等等，HR 那边说有点麻烦，明天应该就好了，我说好。结果第二天告诉我要走一个面试的流程，好嘛，那就走吧，约了时间又去面试（其实本来是要电话面的，我说正式当面面吧）。结果一面差点翻车，面试官小哥还蛮严肃的，最后还是靠了一句 FP 实现反杀；二面大佬说不聊技术了，聊聊你之前为啥离职的，然后随便聊了聊… 大佬又告诫说我兴趣面太广也不太好，要专注一个点，出了成果后再去考虑其他点… 还和我说了说美团这边的评定等级的制度，内部一些不成文的规矩等等等等，聊了得有一个小时吧。然后就是一个挺漂亮的 HR 小姐姐，来和我说明了工资，福利等常规问题，结果最后突然问我：“你觉得你的性格怎么样？” 我：“呃，不知道，感觉还好吧…” HR 说：“你是个个性很强的人” 我：“…” 反正之前没人这么说过我…</p><p>按照正常剧本我这个情况只要等 offer 入职就好了。结果当天晚上回家，就有猎头给我打电话问我是不是刚从猫眼离职，在寻找新的机会。我：“？？？” 还有这种操作。</p><p>因为如果是通过 boss 直聘或者其他渠道拿到我的简历的猎头，都会问我是不是还在职，这个直接就知道我离职了，感觉是我的信息被猫眼 HR 给卖了…</p><p>我说确实是离职了，但是已经确定要转岗去美团金服了。</p><p>结果，猎头告诉我说：“你这种情况是转不了岗了。我也有美团那边的朋友，那边的规矩我们也懂。美团转岗是需要之前部门领导签字同意的…”</p><p>我：“…” 总之是不太相信，然后微笑着拒绝了猎头的好意</p><p>……</p><p>然后第二天中午美团金服的 HR 就打来电话，告诉我很抱歉，虽然…尽管…非常抱歉…</p><p>我有点不太相信… 又微信问了下那边的 leader 是不是我的技术表现得不太好（毕竟一面差点翻车），leader 给我回的语音说不是的，我的技术还不错，没能转岗是因为美团对我这个职级的要求比较苛刻，需要绩效优秀以及之前部门领导的签字同意…</p><p>GG…</p><p>本来还想在微博/知乎/朋友圈撕一下这个事情的，不能吃哑巴亏是不是… 不过在美团（猫眼）的将近半年时间，也得到了很多大佬的提携指点，还是算了吧。要怪就怪公司不完善的制度吧。（当然了，如果你要去猫眼新业务技术部工作，say no）</p><p>仅以此文纪念。</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2017/09/16/how-i-left-maoyan/#disqus_thread</comments>
    </item>
    
    <item>
      <title>我的 Emacs 配置</title>
      <link>https://stevearzh.github.io/2015/11/21/emacs-config/</link>
      <guid>https://stevearzh.github.io/2015/11/21/emacs-config/</guid>
      <pubDate>Sat, 21 Nov 2015 10:42:25 GMT</pubDate>
      <description>
      
        
        
          &lt;h2 id=&quot;emacs&quot;&gt;&lt;a href=&quot;#emacs&quot; class=&quot;headerlink&quot; title=&quot;.emacs&quot;&gt;&lt;/a&gt;.emacs&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://gist.github.com/Stevearzh/4509b3b516e9b
        
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="emacs"><a href="#emacs" class="headerlink" title=".emacs"></a>.emacs</h2><p><a href="https://gist.github.com/Stevearzh/4509b3b516e9bbb1d017" target="_blank" rel="noopener">https://gist.github.com/Stevearzh/4509b3b516e9bbb1d017</a></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><p>molokai-theme</p></li><li><p>markdown-mode</p></li><li><p>auto-complete</p></li><li><p>highlight-indentation</p></li><li><p>web-mode</p></li><li><p>sass-mode</p></li><li><p>rainbow-mode</p></li><li><p>erc-hl-nicks</p></li><li><p>2048-game</p></li><li><p>eshell-autojump</p></li><li><p>eshell-git-prompt</p></li></ul>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2015/11/21/emacs-config/#disqus_thread</comments>
    </item>
    
    <item>
      <title>在 Sublime Text 中设置环境变量</title>
      <link>https://stevearzh.github.io/2015/07/03/SublimeREPL-Shell-Path-Hack/</link>
      <guid>https://stevearzh.github.io/2015/07/03/SublimeREPL-Shell-Path-Hack/</guid>
      <pubDate>Fri, 03 Jul 2015 15:12:35 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;我用的是 Sublime Text 2，3 支不支持没有测试过。&lt;/p&gt;
&lt;p&gt;首先通过 Sublime Text 里的 Package Control 安装 &lt;a href=&quot;https://packagecontrol.io/packages/SublimeREPL&quot; 
        
      
      </description>
      
      <content:encoded><![CDATA[<p>我用的是 Sublime Text 2，3 支不支持没有测试过。</p><p>首先通过 Sublime Text 里的 Package Control 安装 <a href="https://packagecontrol.io/packages/SublimeREPL" target="_blank" rel="noopener">SublimeREPL 插件</a>，这步就不再多提。</p><p>起因是学习 coursera 上的 <a href="https://class.coursera.org/algs4partI-008" target="_blank" rel="noopener">Algorithms, Part I</a>，里面的算法是通过 java 实现的。不过不是标准的 java，构建项目的时候需要用到普林斯顿大学自己定制的一个 <a href="http://introcs.cs.princeton.edu/java/stdlib/" target="_blank" rel="noopener">java 包</a>。</p><p>无奈实在不想用 eclipse，经 ASenR 介绍，发现可以配置一个<a href="http://algs4.cs.princeton.edu/linux/" target="_blank" rel="noopener">终端环境</a>。完成配置后向 <code>~/.zshrc</code> 中的 PATH 后添加 <code>$HOME/algs4/bin</code>，iTerm 下通过 <code>javac-algs4</code> 编译再由 <code>java-algs4</code> 可以编译运行课程中的代码了。但是发现 SublimeREPL 里的 shell 中的环境变量里还是没有 <code>$HOME/algs4/bin</code>，在网上搜索后找到了一个<a href="http://robdodson.me/hacking-the-path-variable-in-sublime-text/" target="_blank" rel="noopener">方法</a>：</p><p><strong> 注意：若使用以下方法表明您已同意自行承担由此引发的所有后果！ </strong></p><p>我们知道， Sublime Text 因为其出色的可扩展性而为众多用户所喜爱，用户可以轻松地添加、使用各种各样的插件。其原理是你放在 <code>~/Library/Application Support/Sublime Text 2/Packages/User/</code>（针对 OS X，Win 和 Linux 请自行查找对应目录）目录下的任意 <code>.py</code> 文件都会在 Sublime Text 启动时自动运行，参考<a href="http://www.sublimetext.com/docs/plugin-basics" target="_blank" rel="noopener">官方文档</a>可以和容易得写出各种插件。不过我们的目的只是修改一个环境变量而已，无需写插件。</p><p>首先打开终端，在插件目录下新建一个名为 <code>add_path.py</code> 的文件：</p><pre><code>cd ~&#x2F;Library&#x2F;Application\ Support&#x2F;Sublime\ Text\ 2&#x2F;Packages&#x2F;User&#x2F;nano add_path.py</code></pre><p>然后在打开的编辑器中输入以下代码：<br><pre><code>import osLOCAL = &#39;&#x2F;Users&#x2F;Stevearzh&#x2F;algs4&#x2F;bin&#39;  ### replace this path to whatever you want #### Sublime&#39;s default path is# &#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbinos.environ[&#39;PATH&#39;] += &#39;:&#39;  os.environ[&#39;PATH&#39;] += LOCAL  print &#39;PATH = &#39; + os.environ[&#39;PATH&#39;]</code></pre></p><p><code>ctrl + x</code> 保存文件，然后重启 Sublime Text 2。同时按下 <code>Command + Shift + P</code>，输入 shell 回车打开 bash。输入 <code>echo $PATH</code> 可得到以下结果，表明环境变量已被成功修改：</p><pre><code>bash-3.2$ echo $PATH&#x2F;usr&#x2F;bin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;sbin:&#x2F;Users&#x2F;Stevearzh&#x2F;algs4&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;bin</code></pre>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2015/07/03/SublimeREPL-Shell-Path-Hack/#disqus_thread</comments>
    </item>
    
    <item>
      <title>随便写写</title>
      <link>https://stevearzh.github.io/2015/06/23/write-something/</link>
      <guid>https://stevearzh.github.io/2015/06/23/write-something/</guid>
      <pubDate>Tue, 23 Jun 2015 15:00:31 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;下午看到 &lt;a href=&quot;http://www.parallels.com/cn/products/desktop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Parallels Desktop&lt;/a&gt; 七五折特价，赶紧入了一个。买完发现密匙的标注是“
        
      
      </description>
      
      <content:encoded><![CDATA[<p>下午看到 <a href="http://www.parallels.com/cn/products/desktop" target="_blank" rel="noopener">Parallels Desktop</a> 七五折特价，赶紧入了一个。买完发现密匙的标注是“<strong>单机版密钥(只能固定在一台电脑上使用)</strong>”(!@#$%^&amp;*)。直接把以前 VM Fusion 里的 Win 8.1 虚拟机迁移过来，发现 Parallels 确实不错，跑老滚五都非常流畅。</p><p>然后晚上回家搜 Mac 上的 Xbox 360 手柄驱动，居然<a href="https://github.com/d235j/360Controller" target="_blank" rel="noopener">找到了</a>！感谢万能的 Github！测试了几个游戏都完全没有问题，手柄指示灯和振动也工作正常。感觉很爽！</p><p>这样一来就更不舍得把 OS X 格掉装 Arch 了…. 还是等以后买新电脑再说吧。</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2015/06/23/write-something/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spelunky</title>
      <link>https://stevearzh.github.io/2015/04/26/Spelunky/</link>
      <guid>https://stevearzh.github.io/2015/04/26/Spelunky/</guid>
      <pubDate>Sat, 25 Apr 2015 16:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;作为一名 Steam 玩家，博主来安利一款游戏 —— Spelunky。商店页面&lt;a href=&quot;http://store.steampowered.com/app/239350/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;请戳这里&lt;/a&gt;。&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<p>作为一名 Steam 玩家，博主来安利一款游戏 —— Spelunky。商店页面<a href="http://store.steampowered.com/app/239350/" target="_blank" rel="noopener">请戳这里</a>。</p><p><img src="/img/Spelunky/Spelunky.jpg" alt=""></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Spelunky 是一款<a href="http://pre-sence.com/archives/roguelike-dossier" target="_blank" rel="noopener">类 Roguelike</a> 游戏。主角是个带著帽子、拿著皮鞭的冒险者，在游戏中四处搜刮宝藏。这款游戏跟 <a href="http://stevearzh.me/2014/12/14/how-to-play-nethack/" target="_blank" rel="noopener">NetHack</a> 的相似之处在于：</p><ol><li><p>每次关卡都是随机产生的，每次游戏都不一样</p></li><li><p>游戏当中的细节常常能让人会心一笑</p></li></ol><p>这样的游戏背景设定，马上会让人想到《夺宝奇兵》电影系列的主角印第安纳·琼斯，而事实也正是如此。</p><p><img src="/img/Spelunky/Indiana_Jones_Role.jpg" alt=""></p><p>Spelunky 也是个非常考验反应能力的动作游戏（所以很容易死掉），因此对于单纯想让大脑休息的人来说，是个真正适合打发时间的游戏。虽然 Spelunky 没有解谜成分，但并不代表着这款游戏就没有任何内涵。前面说过了，这游戏里面有一大堆印第安纳·琼斯的梗，而且随著关卡推进，会有多种不同的场景地形的变化，以及多样的道具、武器。你需要不断改变操作策略，才能在一个又一个的关卡间全身而退。</p><p>如果你不相信这个游戏的背后是印第安纳．琼斯，那么走下去吧！在某些关卡，你会看到这样的黄金雕像：</p><p><img src="/img/Spelunky/Golden_Head_Statue.jpg" alt=""></p><p>就跟印第安·纳琼斯第一集一开始的一模一样！如果你能够把黄金雕像带到这一关的出口，就可以多赚到不少钱。不过，小心，就跟电影一样，当你把黄金雕像捡起来后….</p><p><img src="/img/Spelunky/Killed_By_Stone.jpg" alt=""></p><p>就会出现滚动的大石头！如果跑得太慢，就会像上图一样直接阵亡了。</p><p>基本上任何在你手上的东西几乎都可以当做武器来使用，所以你可以把前述的黄金雕像当做武器丢出去砸敌人（再捡回来就好了）—— 稍后你还会有拯救美女的机会，美女也可以丢出去打人，真是太让人感到愉快了！(但拯救美女过关是可以给自己加一滴血的，而且美女的血量是有限的，所以，悠着点….)</p><p><img src="/img/Spelunky/Pick_Up_Something.jpg" alt=""></p><p>这款游戏还有许许多多丰富有趣的设计，为了不破坏大家的乐趣，在这里我就不多说了。</p><p>另外，需要特别注意的一点是：每一关游戏超过一定时间后，就会出现一只你打不死的鬼魂来追杀你，所以你最好尽快离开每一关关卡。</p><p><img src="/img/Spelunky/Ghost.jpg" alt=""></p><p>Spelunky 的设计是你一定很容易死、经常会死，因此并没有所谓的存档这回事。但我们可以采用另一种方法 ——</p><h2 id="捷径"><a href="#捷径" class="headerlink" title="捷径"></a>捷径</h2><p>在游戏中，从一幕到另一幕之间，会有一个捷径工人向你索取炸弹和绳索（各两个），以及特殊物品（金钱、散弹枪、钥匙），分别提供之后，工人就可以帮你盖出日后前往该幕的捷径。</p><p><img src="/img/Spelunky/To_Forest.jpg" alt=""><br>前往丛林的捷径</p><p>也就是说，你要分三次通过相邻两幕之间的洞穴隧道，第一次向工人提供炸弹，第二次提供绳索，第三次提供特殊物品 —— 前往森林（第 5 关）的捷径需要金钱一万，前往洞窟（第 9 关）的捷径需要散弹枪，前往祭坛（第 13 关）的捷径需要钥匙。（部分条件可能不准确）</p><p><img src="/img/Spelunky/To_Grotto.jpg" alt=""><br>前往洞穴的捷径</p><h2 id="幕景介绍"><a href="#幕景介绍" class="headerlink" title="幕景介绍"></a>幕景介绍</h2><p>游戏总共有四幕，说明如下：</p><ul><li><p>第 1 到第 4 关是洞穴，是最简单的区域，会遇到的敌人包括有：蝙蝠、蛇、蜘蛛、骷髅怪、穴居野蛮人，另外也有机会遇到大蜘蛛；洞穴中会有弓箭陷阱、尖刺、蜘蛛网等陷阱。</p></li><li><p>第 5 到第 8 关是森林，你可能会从很高的地方摔下来，所以往下跳前要小心。会遇到的敌人包括有：青蛙、火青蛙、食人鱼、食人花、僵尸、骷髅怪、穴居野蛮人，另外也有机会遇到巨型食人鱼；还有猴子虽然不会直接攻击你，但是却可能让你送命；森林中会有尖刺窟、图腾柱、水池等陷阱。</p></li><li><p>第 9 到 12 关是洞窟，结冰的路面会滑，而且整个洞窟都是深不见底，掉到底下会马上死掉，洞窟中的敌人有飞碟、外星人、雪人、骷髅怪、穴居野蛮人，而且会有机会遇到巨型雪人跟巨型外星人；洞窟中会有弹跳板、冰、尖刺等陷阱。</p></li><li><p>第 13 到 16 关是祭坛，是非常危险的区域，这里的敌人有穴居野蛮人跟教徒，另外会有巨型木乃伊，然后有弓箭陷阱、会动的尖刺砖块、图腾柱、岩浆等陷阱。</p></li><li><p>第 16 关是最后一关，所有的敌人都会出现，另外还有本游戏最终大头目：大金头（我知道这个名字听起来实在很蠢），底下还有岩浆，祝好运！</p></li></ul><h2 id="信息提示"><a href="#信息提示" class="headerlink" title="信息提示"></a>信息提示</h2><p>在某些关卡开始时，主角会喃喃自语地讲一些话，这些话都是有意义的：</p><p><img src="/img/Spelunky/Cannot_See.jpg" alt=""></p><blockquote><p>I can’t see a thing!</p></blockquote><p>表示这一关是乌漆麻黑的，只有你自己点燃的火焰、商店的油灯、熔岩、黄金圣甲虫、弓箭陷阱等能制造光源，照亮附近。</p><blockquote><p>I hear snakes… I hate snakes!</p></blockquote><p>这可是印第安纳·琼斯的经典名句，表示这一关有个蛇窟，如果你冒险进入蛇窟，用炸药炸开蛇窟底端，就有机会找到可以挖掘的工具鹤嘴锄（有使用次数限制）。</p><blockquote><p>The dead are restless!</p></blockquote><p>表示你进入了森林区域中的 Restless Dead 特殊关卡，会有大量的僵尸与骷髅怪出现。还会出现吸血鬼，打死吸血鬼后会掉落宝物披风（装备披风后按住跳跃键不动可以在空中滑行）。你也可以发现带着王冠的骷髅头（捡起王冠可以加很多钱）以及鬼魂石（捡起或碰撞鬼魂石会提前召唤出鬼魂来击杀你）等特殊物品。</p><blockquote><p>You hear rushing water…</p></blockquote><p>表示这一关底部有个大水池，而且里面会有巨型食人鱼。</p><blockquote><p>It smells like wet fur in here!</p></blockquote><p>表示这一关会有更多雪人，而且还会有巨型雪人出没。</p><blockquote><p>There’s a psychic presence here!</p></blockquote><p>表示这一关有巨型外星人。</p><blockquote><p>I can hear prayers to Kali!</p></blockquote><p>这也是印第安纳·琼斯的梗（系列电影第二部：《魔宫传奇》），表示这一关底端有个很深的熔岩窟，而且会有个地板陷阱，上面有美女和黄金雕像。</p><blockquote><p>It’s the legendary City of Gold!</p></blockquote><p>恭喜你，你进入了黄金城！</p><h2 id="黄金城攻略"><a href="#黄金城攻略" class="headerlink" title="黄金城攻略"></a>黄金城攻略</h2><p>那么要怎样找到传说中的黄金城呢？简单来说，在每一幕都有必须要完成的事：</p><ol><li><p>在洞穴的某一关你会找到一把钥匙，同一关也会有个上锁的大箱子，用钥匙打开大箱子，获得观察之眼(Udjet Eye)。</p></li><li><p>在森林的某一关会藏有黑市秘密入口，这个入口必须用炸药炸开才能进入，而且观察之眼在靠近这个入口时会开始眨眼，眨越快表示越靠近。</p></li><li><p>进入黑市，有一间商店会卖生命十字架（Ankh），花五万元买下。由于商店通缉是连锁的，所以进入黑市前最好不要对任何商店动歪主意。</p></li><li><p>洞窟的某一关会有巨大的生命十字架雕像，在这一关自杀，复活之后取得白皇冠（Hedjet）；要注意的是在这一关之前绝对不能死掉，否则会把生命十字架提早用掉。</p></li><li><p>在祭坛当中杀死巨型木乃伊，取得权杖（scepter），与白皇冠合用就可解开黄金城的入口。</p></li></ol><h2 id="小游戏"><a href="#小游戏" class="headerlink" title="小游戏"></a>小游戏</h2><p>此外，游戏中还有四个不同的小游戏，开启条件如下：</p><ul><li><p>太阳房 —— 只要你在游戏中任何时候身上有累积到二十万资产，就会开启太阳房；太阳房的小游戏是要你跟美女在重重机关陷阱中，尽可能存活越久越好。</p></li><li><p>月亮房 —— 在 10 分钟之内击败第 17 关的最终头目、赢得游戏，就会开启月亮房；月亮房的小游戏是要用弓箭射击移动的标靶。</p></li><li><p>星星房 —— 在任一场游戏中杀死超过 120 个敌人，就会开启星星房；星星房的小游戏是要拿散弹枪猎杀商店老板们，不过要是他们碰到你，你就输了。</p></li><li><p>角色交换房 —— 在任一场游戏中拯救美女 8 次以上，就会开启角色交换房；这会让你的角色跟美女交换──也就是你可以用美女进行游戏，拯救带帽子的阿宅冒险者……</p></li></ul>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2015/04/26/Spelunky/#disqus_thread</comments>
    </item>
    
    <item>
      <title>响应式网页设计</title>
      <link>https://stevearzh.github.io/2015/04/19/Responsive-Web-Design/</link>
      <guid>https://stevearzh.github.io/2015/04/19/Responsive-Web-Design/</guid>
      <pubDate>Sun, 19 Apr 2015 05:38:55 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;我们所熟悉的网络正飞速发展着。过去，开发设计人员在制作网页时，只需考虑计算机屏幕即可。但近几年来，各式各样的网页浏览设备层出不穷，这些设备的外形和性能千差万别。这意味着如今，在网页制作过程中，我们不得不尽可能的考虑所有情况，以使网页能够适应不同设备的屏幕尺寸、外形和分辨率。
        
      
      </description>
      
      <content:encoded><![CDATA[<p>我们所熟悉的网络正飞速发展着。过去，开发设计人员在制作网页时，只需考虑计算机屏幕即可。但近几年来，各式各样的网页浏览设备层出不穷，这些设备的外形和性能千差万别。这意味着如今，在网页制作过程中，我们不得不尽可能的考虑所有情况，以使网页能够适应不同设备的屏幕尺寸、外形和分辨率。</p><p>以往惯用的定宽页面设计现在已经过时了。那么我们该怎么做呢？答案是：响应式网页设计。</p><h2 id="什么是响应式网页设计？"><a href="#什么是响应式网页设计？" class="headerlink" title="什么是响应式网页设计？"></a>什么是响应式网页设计？</h2><p>响应式网页设计的想法，由 <a href="http://unstoppablerobotninja.com/" target="_blank" rel="noopener">Ethan Marcotte</a> 提出，他认为网页应针对不同的浏览设备，自动切换页面布局和设计风格。</p><p>在他的书作 <a href="http://www.abookapart.com/products/responsive-web-design" target="_blank" rel="noopener">Responsive Web Design</a> 中，他提出了响应式网页的三个要素：</p><ol><li><p>流动式栅格</p></li><li><p>流动式图片</p></li><li><p>媒体查询</p></li></ol><p>因为这篇文章主要是写给设计人员<strong>而非开发人员</strong>的，再者我也不想班门弄斧，所以就不再多提以上三点了。</p><p>不过，对设计人员来说，想要设计更好的网页，就有必要了解 RWD(Responsive Web Design) 的基本要素，只有这样才能更加容易地完成代码编写。我强烈建议你们阅读以下三篇 Ethan 的文章：<a href="http://www.alistapart.com/articles/fluidgrids/" target="_blank" rel="noopener">Fluid Grids</a>、<a href="http://unstoppablerobotninja.com/entry/fluid-images" target="_blank" rel="noopener">Fluid Images</a> 以及 <a href="http://www.alistapart.com/articles/responsive-web-design" target="_blank" rel="noopener">Responsive Web Design</a>。</p><p><img src="/img/Responsive-Web-Design/responsive-web-design2.jpg" alt=""></p><p>插图：<a href="http://www.alistapart.com/authors/c/kevincornell" target="_blank" rel="noopener">Kevin Cornell</a></p><p>请务必读最后一篇文章，那是去年（2010 年）五月写的。阅读这篇文章改变了我，我猜很多人和我一样，通过这篇文章重新认识了 Internet。Ethan 的工作已经不能用卓越来形容了，我相信每个 Web 工作者都会从这片文章里得到启示。</p><h2 id="设计者原则"><a href="#设计者原则" class="headerlink" title="设计者原则"></a>设计者原则</h2><p>如果你是那种<strong>只负责设计</strong>的设计人员，或者说你并不熟悉你所设计站点的 HTML 和 CSS，那你的脑子里现在一定充满了疑问。你甚至也许会问为什么你一定需要了解响应式网页设计。</p><p>我一直认为设计网页的人是通过 HTML 和 CSS 来展现当前生活中的元素的。我明白对很多项目来说这显然是不必要的，我也同意设计人员选择<strong>只是</strong>进行设计或者<strong>只是</strong>进行写代码。</p><p>但必须明白一个道理：网页既非单纯的设计亦非单纯的代码，而是二者的紧密集合，缺少任何一个都将无法编写出网页来。要想真正了解如何设计一个网页，你<strong>必须</strong>知道设计是如何转化为代码的，即使只是最基本的了解。</p><p>这里再次提醒一下：这篇文章是针对设计人员来写的。在接下来的文章里，我将以实例说明作为设计人员，为什么我们应该改变设计方式以更好的适应响应式网页开发。</p><h2 id="栅格"><a href="#栅格" class="headerlink" title="栅格"></a>栅格</h2><p><img src="/img/Responsive-Web-Design/grids.png" alt=""></p><p>一个标准的、基于网格设计的<a href="http://www.thegridsystem.org/" target="_blank" rel="noopener">栅格</a>示例，建议仔细阅读</p><p>即使你不准备设计响应式的网页，你也会在设计中或多或少的用到栅格。作为一个受过教育的的现代设计人员，你应该早就明白了为什么要使用栅格，这里我就不再多提。</p><p>响应式网页设计的核心之一就是流动式栅格。确切来说，这表示你的栅格不应该再按照以前的像素大小来规定尺寸，而是应该按照所占整个页面的百分比进行处理。经过详细计算的响应式网页中每栏的宽度会随着浏览器窗口的宽度而改变，但不能保证在不同设备上有同样的表现。</p><p>这也是为什么当你设计响应式网页时一定要<strong>使用栅格</strong>的原因。这是必须的，而非优先考虑的。你<strong>绝对不能</strong>不使用网格制作响应式网页；原因很简单，你如果这样做网页将不能正常显示。</p><p>了解这些后，你在设计中一定不会再使用像素来设置每栏的宽度了，当然还有一些其他你应该注意的地方，通过这些确保你的栅格分栏不会出现问题。</p><ol><li><p>切莫在你的分栏中使用带有纹理的边框，就像下面这样：</p><p> <img src="/img/Responsive-Web-Design/textured_borders.png" alt=""></p><p> 这些纹理会加大开发者制作响应式网页的难度，因为纹理在水平缩放上表现得并不好。当你尝试缩放边栏时，带有纹理的边框就会变得扭曲。</p></li><li><p>水平式渐变是另一个禁区：</p><p> <img src="/img/Responsive-Web-Design/horizontal_gradient.png" alt=""></p><p> 和上一条的原因一样，这会给开发者造成不小的麻烦，不要这样做。虽然使用 CSS3 的新特性可以很容易实现，但如果浏览你网页的用户没有任何技术常识，那么他们很可能没有使用支持 CSS3 的新特性的浏览器，你的努力也就白费了。（译注：现在的浏览器基本已经都支持 CSS3 的新特性了）</p></li><li><p>如果你确实需要在分栏中使用带有纹理的边框，请确保该边框是那种易于平铺的。<strong>一定需要</strong>：规则的花边、坠饰等。<strong>绝对避免</strong>：使用照片、插图，或者其他不能平铺的图像。</p></li></ol><h2 id="不同的比例"><a href="#不同的比例" class="headerlink" title="不同的比例"></a>不同的比例</h2><p>水平缩放你的页面设计以适应小屏幕设备，但另一个问题随之出现——某些字体会变得过大。是的，有个 100 像素的标题在你的 psd 里看起来还不错，但另一方面这在 iPhone 屏幕上将不会正常显示，原因很简单：文本太大了，以至于会占用后面的几行，导致你预期的设计失效。</p><p>这种时候，开发人员就会使用 CSS 的媒体查询特点，使 CSS 能根据屏幕的大小来自动调整字体尺寸。这是一种设计据测，作为一个设计师你是有发言权的，对吧？</p><p>为了减轻开发者的负担，也为了尽量还原你的设计初衷，你需要考虑哪些文本应该在页面上保持大小不变。或者说，文本是可以随时调整的，应该在不同尺寸的屏幕上保持相同的比例。当然可以使正文部分的文本保持尺寸固定，也可以使用较小的的标题作为正文文本的较大版本。</p><p>同时需要考虑将要被调整的字体，应该<strong>如何</strong>进行调整。</p><p>错误的方法是这样的：<strong>x</strong> 总是比 <strong>y</strong> 大 20 像素。这样做不仅仅会给开发者造成不小的麻烦，对于响应式工作区域也没有太大的意义，因为你正在把一个常量作为考虑因素，这个常量的值无论屏幕尺寸怎样都不会发生变化。在响应式网页设计中，这是一个巨大的错误，因为该方法未考虑到网络浏览设备的易变性。</p><p>正确的方法是这样的：<strong>x</strong> 总是 <strong>y</strong> 的 1.5 倍。这种做法只接受真正意义上的脱离了字体实际大小的设计，也就是字体的大小是相对页面上其他字体的大小而言的。确切的值，像 24 像素或者 67 像素这样的，是没有意义的。</p><p>在你理解了这些之后，请把它们转述给开发者。这是唯一能够确保你的设计初衷，被完全展示在浏览网页的读者眼前的方法。</p><h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>媒体查询是响应式的最后一块拼图。这方面你也许不了解，媒体查询是一种能通过探测浏览器的不同尺寸从而使用不同的 CSS 的技术。</p><p>这种技术的绝妙之处在于，你可以调整甚至重设计你的整体页面布局，以适应比你的原稿设计更大或者更小的浏览器。</p><p>为了达到更好的设计效果，你有必要思考你的设计中的不同部分，比如：正文、侧边栏、标题、导航栏等，它们并非要像拼图一样必须放在固定的位置上，而是像<strong>模块</strong>一样再组织，重新设定尺寸，并打乱先前的顺序排列。</p><p>举个例子：假如你正在设计一个这样的网页（我猜你之前一定设计过类似的网页）：</p><p><img src="/img/Responsive-Web-Design/modules_original.png" alt=""></p><p>这个例子的关键之处在于，所有元素必须处于特定的分组位置上。比如，所有的导航链接必须放置在一起，否则就没有任何意义了。这就是模块，一系列组合在一起的元素，把它们放入其他模块中并不会失去它们的原有意义。</p><p>使用模块构建你的页面可以使得构思在不同设备上的布局变得更加容易。像下面这样：</p><p><img src="/img/Responsive-Web-Design/modules_resized.png" alt=""></p><p>看见了吗？即使模块的位置改变了，但它们显示的信息及其组织方式却没有发生变化，这使得页面在移动设备或不同尺寸浏览器上的呈现效果更加友好。</p><p>你无须改变你的布局使页面呈现出模块化的效果，以上示例不过是同一页面的不同展现效果。尽管如此，这些新知识也会让你在今后的设计工作中做出更多的思考。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同许多其他互联网上的事物一样，响应式网页设计是逐渐发展而来的，而非某场革命造就的。它是 Web 衍化道路上的一小步，不是推倒重建的新生产物。作为设计人员，我们要做的不过是接受新事物，这次也没有什么不同。</p><p>响应式网页设计<strong>仍是</strong>将来时，至少要等到开发人员和设计人员都接受它。作为网页设计开发人员，我们是唯一有力量去实现、去亲眼见证这些发生的。为了你、为了我、为了互联网，让我们一起加油！</p><hr><p>原文: <a href="http://webdesign.tutsplus.com/articles/designing-for-a-responsive-web--webdesign-3850" target="_blank" rel="noopener">http://webdesign.tutsplus.com/articles/designing-for-a-responsive-web–webdesign-3850</a></p><p>作者：<a href="http://tutsplus.com/authors/max-luzuriaga" target="_blank" rel="noopener">Max Luzuriaga</a> 翻译：<a href="http://stevearzh.me" target="_blank" rel="noopener">Stevearzh</a></p><p>转载请注明。</p>]]></content:encoded>
      
      <comments>https://stevearzh.github.io/2015/04/19/Responsive-Web-Design/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
